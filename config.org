#+TITLE: Emacs configuration file
#+AUTHOR: Sriram Krishnaswamy

#+OPTIONS: num:nil tags:nil todo:nil p:nil pri:nil stat:nil c:nil d:nil
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+EXCLUDE_TAGS: noexport

* Basics

My configuration is modal in nature. The best example of a modal editor is [[https://en.wikipedia.org/wiki/Vim_(text_editor)][Vim]]. In fact, I use Vim every now and then and was a Vim user for almost 4 years before I switched to Emacs (primarily because of [[http://orgmode.org][Org mode]]). I like modal editing as a concept and have set it up that way. That's probably the most important thing about this configuration. This is better explained under the section - [[*Modal states][Modal states]].

The best way to get help is to ask Emacs about it. =C-h= is the prefix key for getting help. This means pressing *Control* and *h* together. So, if you are new to Emacs you might want to start by pressing =C-h C-h=, i.e., press =C-h= twice. Everything else regarding help will be explained along the way.

Finally, all Emacs configuration resides in a directory named the =user-emacs-directory= which is =~/.emacs.d= in most UNIX-like systems and all changes/configuration for Emacs is stored in a file called [[*Init file][init.el]]. The most important command, IMO, =M-x= which stands for press "Meta" and then press x. "Meta" is usually the =Alt= key.

Also, the current configuration is tested only on OS X so far.

To get the complete list of key-bindings, [[*Key bindings][check out the relevant section]].

** Installing Emacs

On OS X, the best way to install Emacs is to use the [[https://github.com/railwaycat/emacs-mac-port][Emacs Mac Port]]. It can easily be done via the command line after installing [[http://brew.sh][Homebrew]] like so:

#+NAME: Installing Emacs via Shell script
#+BEGIN_SRC sh :tangle no
brew tap railwaycat/emacsmacport
brew install emacs-mac --with-gnutls --with-imagemagick --with-xml2 --with-d-bus --with-modern-icon
brew linkapps emacs-mac
#+END_SRC

Note that, in this port, the "Meta" key is actually the OS X =Command= key. I prefer it this way but if you want to change this to the =Option= key, you need to put the following code in the appropriate place in [[*Defaults][Defaults]], or in your =init.el= file.

#+BEGIN_SRC emacs-lisp :tangle no
(when (eq system-type 'darwin)
  (setq mac-option-modifier 'meta))
#+END_SRC

To install GNU Emacs,

#+BEGIN_SRC sh :tangle no
brew install emacs --with-imagemagick --with-d-bud --with-cocoa
#+END_SRC

** Getting this configuration

This configuration resides on [[https://github.com][GitHub]] in [[https://github.com/sriramkswamy/dotemacs][my repository]].

If you have an already existing configuration, it is better to back it up.

#+BEGIN_SRC sh :tangle no
mv ~/.emacs.d ~/.emacs.d.bak
#+END_SRC

Else, you can just delete it.

#+BEGIN_SRC sh :tangle no
rm -rf ~/.emacs.d
#+END_SRC

Then, clone this repository in ~.emacs.d~

#+BEGIN_SRC sh :tangle no
git clone https://github.com/sriramkswamy/dotemacs.git ~/.emacs.d
#+END_SRC

If you are just updating the configuration, you can just pull the latest changes

#+BEGIN_SRC sh :tangle no
cd ~/.emacs.d && git pull
#+END_SRC

** Init file

The =init.el= file in the Emacs directory is the file Emacs looks to load when it starts up. Since I'm planning to have THIS org file as my configuration file, The actual =init.el= file is very simple. I first increase the garbage collection to around 500 MB so that Emacs doesn't pause much during the load. Then, I add a few repositories for us to download [[*Packages][packages]] from. Finally, I make sure Org and [[*Org contributed packages][Org contributed packages]] are installed before telling [[*Org babel][Org babel]] to load this file. Finally, I reduce the threshold for garbage collection once again so that Emacs functions smoothly.

#+BEGIN_SRC emacs-lisp :tangle no
;;; init.el --- Global settings -*- lexical-binding: t; -*-

;;; Commentary:

;; Here be dragons

;;; Code:

;; Increase the garbage collection threshold to 500 MB to ease startup
(setq gc-cons-threshold (* 500 1024 1024))

;; List package archives and initialize them
(require 'package)
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))
(when (< emacs-major-version 24)
  ;; For important compatibility libraries like cl-lib
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))
(package-initialize)

;; Make sure Org is installed
(unless (package-installed-p 'org)
  (package-refresh-contents)
  (package-install 'org))

;; Org plus contrib needs to be loaded before any org related functionality is called
(unless (package-installed-p 'org-plus-contrib)
  (package-refresh-contents)
  (package-install 'org-plus-contrib))

;; Load config.org - my Emacs configuration
(org-babel-load-file (concat user-emacs-directory "config.org"))

;; Garbage collector - decrease threshold to 5 MB
(add-hook 'after-init-hook (lambda () (setq gc-cons-threshold (* 5 1024 1024))))
;;; init.el ends here
#+END_SRC

Emacs has a built-in garbage collection mechanism (read [[https://medium.com/@yonkeltron/explaining-garbage-collection-algorithms-by-keeping-your-fridge-tidy-2636012cfeee#.wrb2o0q7a][this article]] for a good intro to garbage collection in general). However, the memory size for which it fires is set pretty low and for the right reasons. Since I operate on a pretty good machine, I set it high initially (around 500 MB) and later reduce it. Therefore, the only thing in the =init.el= file is the GC increase, loading this org file and reduce the threshold again.

** Emacs Lisp

Emacs Lisp is the name of the language Emacs we use to configure Emacs. Start with [[http://tonyballantyne.com/tech/1-beginning-emacs-lisp/][this article]] for a good introduction to the language and [[https://github.com/bbatsov/emacs-lisp-style-guide][this one]] for the style of Emacs Lisp.

* Defaults

** Personal information

I'm not too big on letting Emacs manage a lot of personal things but I do want it to know my name. Therefore,

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Sriram Krishnaswamy")
#+END_SRC

** Custom file

Emacs has a built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][customization interface]] that helps beginners customize a lot of options. However it is limited and one needs to grok some Emacs Lisp anyway. Sometimes, I change stuff in my configuration that invokes/adds via the customization interface. This results in automatic inserting of some code into my =init.el= which messes up the version control. We tell Emacs to store in a separate file and load it if it exists.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Packages

Packages are managed by [[https://www.emacswiki.org/emacs/ELPA][package.el]] but it has access to only the default ELPA repository by default. Let's add more repositories and initialize it. Note that the =(package-initialize)= operation takes a while and is one of the major factors that increase startup time. The packages are loaded and initialized in the [[*Init file][Init file]].

** Startup

*** Disabling some GUI elements

Emacs has a different GUI implementation to that of its terminal implementation and I prefer the GUI any day. But there are some things that I find annoying - like tool bar, menu bar, scroll bar and the tool tip. Therefore, I disable it.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1))
#+END_SRC

*** Set the initial frame size

Frames in Emacs parlance are the equivalent of windows in normal usage. So, when you open Emacs, it opens a /frame/ and not a window. Windows are the what splits are referred to. For further reference [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Frames.html][look it up in the Emacs manual]].

#+BEGIN_SRC emacs-lisp
;; initial window
(setq initial-frame-alist
      '((width . 102)   ; characters in a line
        (height . 54))) ; number of lines

;; sebsequent frame
(setq default-frame-alist
      '((width . 100)   ; characters in a line
        (height . 52))) ; number of lines
#+END_SRC

*** Set the cursor shape

Since I use a modal configuration, it is so easy to detect modes by just changing the cursor shape. Also, the "bar" cursor feels more natural because that's what most application outside of Emacs use anyway. Also, while I'm at it, I don't want the cursor to blink either.

#+BEGIN_SRC emacs-lisp
;; Bar cursor
(setq-default cursor-type '(bar . 1))
;; Don't blink the cursor
(blink-cursor-mode -1)
#+END_SRC

*** Initial screen

The default screen of Emacs is just so useless and cluttered with links and text and help pages. I just need a simple start screen which gently reminds me some things that are important while staying out of the most of the time. This is also called the *scratch* buffer.

#+BEGIN_SRC emacs-lisp
;; No welcome screen - opens directly in scratch buffer
(setq inhibit-startup-message t
      initial-scratch-message ";; Scratch

;; Press '?' in Modalka state or 'C-x ?' in Emacs state for bindings list.
;; Press 'SPC ?' in Modalka state or 'C-h b' in Emacs state for searching through bindings.
;; Press 'SPC j' in Modalka state or 'M-x' in Emacs state to access all the functions/commands.
;; Press 'C-h C-h' for help regarding how to use help.
;; Finally, pressing one of the prefix keys and waiting for a second will also show hints.


"
      initial-major-mode 'fundamental-mode
      inhibit-splash-screen t)
#+END_SRC

*** Startup echo message

There is a small advert for GNU that is displayed in the mini-buffer during startup and, of course, [[http://emacs.stackexchange.com/questions/432/how-to-change-default-minibuffer-message][there is a way to change it]].

#+BEGIN_SRC emacs-lisp
;; Change the echo message
(defun display-startup-echo-area-message ()
  (message "Let the games begin!"))
#+END_SRC

** Backups

Emacs takes regular backups of once you switch on auto-saving and, by default, puts the backups in the same directory. This is annoying most of the time since I tend to save pretty often and also clobbers with my file system tree when I'm trying to search within the files. Therefore, [[https://www.emacswiki.org/emacs/BackupDirectory][Emacs wiki]] has a pretty nice solution for that, which keeps various versions of the backup file and stores it under a folder in the home directory.

#+BEGIN_SRC emacs-lisp
;; Backups at .saves folder in the current folder
(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups
#+END_SRC

** Auto saving

I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in some temporary directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
      create-lockfiles nil)
#+END_SRC

** File encoding system

UTF-8 works for most of the files I tend to use

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8-auto-unix)
#+END_SRC

** Error message

Mac has an [[http://stuff-things.net/2015/10/05/emacs-visible-bell-work-around-on-os-x-el-capitan/][annoying bug]] when visibly warning you about errors. I hate it but I'm okay with it ringing a bell when it encounters an error.

#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

** Truncating lines

Emacs has an option to [[https://www.emacswiki.org/emacs/TruncateLines][wrap lines]] which is disabled by default. What this means is that, if the text goes beyond the screen, it will wrap it so that you can see all the text. However, it wraps it with these weird indicators that I find more annoying. Plus, I make sure my code stays within 100 characters always and prefer the soft line wrap while writing prose. Let's make sure it doesn't wrap again.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

** Large file warning

Whenever, a large file (by Emacs standards) is opened, it asks for confirmation whether we really want to open it but the problem is the limit for this file is set pretty low. Let's increase it a bit so that it doesn't prompt so often.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 15 1024 1024))
#+END_SRC

** Lazier prompting

While we are in the topic of prompting, a lot of the default prompts ask for a =yes= or a =no=. I'm lazy and so I don't want to type the full words. Let's just make it accept =y= or =n=.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Expand some words and auto-correct

=abbrev-mode= or abbreviation mode is a built-in mode that auto-corrects the word you mistype on pressing space. For how I practically use it, see [[*Add for auto correction][the auto-correction section]].

#+BEGIN_SRC emacs-lisp
(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)
#+END_SRC

** =gdb=

[[https://www.gnu.org/software/gdb/][gdb]] is the GNU debugger which is used to debug programs. Let's make it multi-windowed like all the other debuggers out there.

#+BEGIN_SRC emacs-lisp
(setq gdb-many-windows t
      gdb-show-main t)
#+END_SRC

** =ediff=

[[https://www.gnu.org/software/emacs/manual/html_node/ediff/][Ediff mode]] is a UNIX patching tool and my version controlling package uses this to help resolve merge conflicts and having some better defaults will be useful for this.

#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

** =dired=

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Dired]] is an amazing file/directory browser that comes bundled with Emacs but I don't like it displaying all the details regarding the files when I open it. I prefer it minimal.

#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'dired-hide-details-mode)
(setq dired-dwim-target t
                  dired-recursive-copies 'top
                  dired-recursive-deletes 'top
                  dired-listing-switches "-alh")
#+END_SRC

** =tramp=

[[https://www.emacswiki.org/emacs/TrampMode][Tramp]] lets you edit files remotely from your local Emacs which is useful because it lets you have all the default configuration. Let's make sure the default protocol is =ssh=.

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh"
      tramp-backup-directory-alist backup-directory-alist
      tramp-ssh-controlmaster-options "ssh")
#+END_SRC

** Move correctly over camelCased words

=subword-mode= is a built-in mode that helps moving over camelCase words correctly.

#+BEGIN_SRC emacs-lisp
(subword-mode)
#+END_SRC

** Better wild cards in search

The built-in incremental search is pretty good but the most common regex I type is =.*= which stands for anything. This makes sure space between words acts the same way. It's much better for me to use it now.

#+BEGIN_SRC emacs-lisp
(setq search-whitespace-regexp ".*?")
#+END_SRC

** Persistent history

I prefer to have some persistent history for some prompts.

#+BEGIN_SRC emacs-lisp
(savehist-mode)
#+END_SRC

** Narrow to region

This is such a an amazing feature but is disabled by default. Let's re-enable it. For further reference on narrow region, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][refer to the Emacs manual]].

#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** PDF files

Emacs has the built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][DocView]] mode which lets me view PDFs. Since I use Org and note taking extensively, I actually prefer reading PDFs in Emacs. Not to mention, this is one of the few PDF readers that lets me view the PDF in split-views which is immensely useful while reading research papers.

#+BEGIN_SRC emacs-lisp
(setq doc-view-continuous t
      doc-view-resolution 300)
#+END_SRC

** Window management

[[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] is an Emacs built-in package that lets you undo and redo window configurations. Incredibly useful since I keep splitting and merging windows all the time. Let's enable it.

#+BEGIN_SRC emacs-lisp
(when (fboundp 'winner-mode)
      (winner-mode 1))
#+END_SRC

** Recent files

An Emacs "mode" is a collection of behavior. It has both major and minor modes. One such useful mode is the =recentf-mode=, which stands for recent files mode. Let's give configure some options and enable it.

#+BEGIN_SRC emacs-lisp
;; Recentf mode changes
(setq recentf-max-saved-items 1000
      recentf-exclude '("/tmp/" "/ssh:"))
(recentf-mode)
#+END_SRC

** Fullscreen

In Mac, the default fullscreen goes to a new workspace. Change this behavior so that it's non-native.

#+BEGIN_SRC emacs-lisp
(setq ns-use-native-fullscreen nil)
#+END_SRC

** Fonts

Switching font is something I do quite often. Also, zooming in text isn't the same as just increasing the font size. So, these are some convenience functions taken from [[https://github.com/incandescentman/Emacs-Settings][Jay Dixit's emacs configuration]].

#+BEGIN_SRC emacs-lisp
(cond ((eq system-type 'gnu/linux)
       (set-frame-font "DejaVu Sans Mono"))
      ((eq system-type 'darwin)
       (set-frame-font "Monaco"))
      ((eq system-type 'windows-nt)
       (set-frame-font "Lucida Sans Typewriter")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;; Some convenience font functions
(defun sk/courier-font ()
  (interactive)
  (set-face-attribute 'default nil :font "Courier")
    (set-frame-width (selected-frame) 97))
(defun sk/georgia-font ()
  (interactive)
  (set-face-attribute 'default nil :font "Georgia" :height 160))
(defun sk/hack-font ()
  (interactive)
  (set-face-attribute 'default nil :font "Hack"))
(defun sk/monaco-font ()
  (interactive)
  (set-face-attribute 'default nil :font "Monaco"))
(defun sk/consolas-font ()
  (interactive)
  (set-face-attribute 'default nil :font "Consolas"))
(defun sk/deja-vu-font ()
  (interactive)
  (set-face-attribute 'default nil :font "DejaVu Sans Mono"))

;; Font types
(defun sk/tiny-type ()
  (interactive)
  (set-face-attribute 'default nil  :height 150))
(defun sk/miniscule-type ()
  (interactive)
  (set-face-attribute 'default nil  :height 140))
(defun sk/small-type ()
  (interactive)
  (set-face-attribute 'default nil  :height 190)
  (set-frame-width (selected-frame) 89))
(defun sk/medium-type ()
  (interactive)
  (set-face-attribute 'default nil  :height 215)
  (set-frame-width (selected-frame) 89))
(defun sk/large-type ()
  (interactive)
  (set-face-attribute 'default nil  :height 350)
  (set-frame-width (selected-frame) 68))
#+END_SRC

* TODO Use package macro

[[https://github.com/jwiegley/use-package][use-package]] is a macro that helps in downloading and managing package a breeze. It has lots of options for lazy loading and configurations and this configuration relies on it completely for all package management. This is a requirement. The following piece of code checks if it is already installed and installs it if it is not and also loads it and bind-key. I should extend this to add key words for =:modalka= and =:which-key=.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile
  (require 'use-package))
(require 'bind-key)                ;; if you use any :bind variant
#+END_SRC

** Diminish minor modes from the mode line

Now that we have made sure we have installed use-package, we will make sure another nice package to change the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Variables.html][mode-line minor mode list]]. For this, we can use use-package itself and also go ahead and diminish some built-in minor modes.

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :demand t
  :diminish (visual-line-mode . "ω")
  :diminish hs-minor-mode
  :diminish abbrev-mode
  :diminish auto-fill-function
  :diminish subword-mode)
#+END_SRC

However, some built-in minor modes are notorious and don't seem to work with the above method. Let's diminish them using functions one by one.

*** Diminish =org-indent= mode

I like to enable the [[http://orgmode.org/manual/Clean-view.html][org-indent mode]] for a clean view in Org mode and this doesn't seem to get diminish the usual way. We define a function and a add a hook to achieve this.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-org-indent ()
  (interactive)
  (diminish 'org-indent-mode ""))
(add-hook 'org-indent-mode-hook 'sk/diminish-org-indent)
#+END_SRC

*** Diminish =auto-revert= mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html][auto-revert mode]] is useful when Emacs auto-saves your file and you want to load the backup.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-auto-revert ()
  (interactive)
  (diminish 'auto-revert-mode ""))
(add-hook 'auto-revert-mode-hook 'sk/diminish-auto-revert)
#+END_SRC

*** Diminish =eldoc= mode

Eldoc mode is a mode to display documentation for languages in Emacs

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-eldoc ()
  (interactive)
  (diminish 'eldoc-mode ""))
(add-hook 'eldoc-mode-hook 'sk/diminish-eldoc)
#+END_SRC

*** Diminish =subword= mode

=subword-mode= is described [[*Move%20correctly%20over%20camelCased%20words][here]].

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-subword ()
  (interactive)
  (diminish 'subword-mode ""))
(add-hook 'subword-mode-hook 'sk/diminish-subword)
#+END_SRC

** Manage the built-in flyspell mode

[[https://www.emacswiki.org/emacs/FlySpell][Flyspell mode]] is a built-in mode for prose spell-checking. It sometimes slows down Emacs. It also has =flyspell-prog-mode= which checks for spelling in programming comments.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :diminish (flyspell-mode . "φ")
  :bind* (("C-z ] s" . flyspell-goto-next-error)))
#+END_SRC

** Add a package to set the correct path

Sometimes when opening the Mac Emacs.app via GUI, by clicking the button, it doesn't load all the proper utilities from the OS. This package fixes that.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :demand t
  :init
  (setq exec-path-from-shell-check-startup-files nil)
  :config
  ;; (exec-path-from-shell-copy-env "PYTHONPATH")
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+END_SRC

** Improve the built-in package menu

[[https://github.com/Malabarba/paradox][Paradox]] improves the built-in menu with github stars and a better regex filter and search. The default key bindings of =i= to install, =U= to update and =x= to execute is still preserved. However, pressing =f= to filter, starts up a hydra to search via regular expressions and more.

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :ensure t
  :commands (paradox-list-packages)
  :init
  (setq paradox-github-token t))
#+END_SRC

** Add some useful libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing, string manipulation, list manipulation and backward compatibility respectively.

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :commands (async-start))

(use-package cl-lib
  :ensure t)

(use-package dash
  :ensure t)

(use-package s
  :ensure t)
#+END_SRC

** Restart emacs from emacs

The heading says it all. I find it useful

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t
  :bind* (("C-x M-c" . restart-emacs)))
#+END_SRC

** Bind key to bind some unbound defaults

There are some pretty nice default functions that are unbound. I use the =bind-key= package that comes along with use-package to bind these keys. I hijack the =C-z= prefix. I find the default action bound to =C-z= (=suspend-frame=) is pretty useless and even if needed can be accessed via =C-x C-z=.

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-w" . backward-kill-word)
  ("C-S-w" . kill-region)
  ("C-S-d" . kill-whole-line)
  ("C-z SPC c"   . load-theme)
  ("C-z g m" . make-frame)
  ("C-z g M" . delete-frame)
  ("C-z g n" . select-frame-by-name)
  ("C-z g N" . set-frame-name)
  ("C-z ="   . indent-region)
  ("C-z g f" . find-file-at-point)
  ("C-z g u" . downcase-region)
  ("C-z g U" . upcase-region)
  ("C-z g C" . capitalize-region)
  ("C-z g O" . occur-edit-mode)
  ("C-z R"   . overwrite-mode)
  ("C-z ."   . repeat)
  ("C-z V"   . rectangle-mark-mode)
  ("C-z g j" . doc-view-next-page)
  ("C-z g k" . doc-view-previous-page)
  ("C-z : t" . emacs-init-time)
  ("C-z g q" . fill-paragraph))
#+END_SRC

* Tangle on save

This was taken from [[https://github.com/alanpearce/dotfiles/blob/master/tag-emacs/emacs.d/init.org#tangling][Alan Pearce's dotfiles]] so as to tangle it on save instead of tangling it every time I open it again.

#+BEGIN_SRC emacs-lisp
(defun tangle-if-init ()
  "If the current buffer is 'init.org' the code-blocks are
    tangled, and the tangled file is compiled."

  (when (string-suffix-p "config.org" (buffer-file-name))
    (tangle-init)))

(defun tangle-init-sync ()
  (interactive)
  (message "Tangling init")
  ;; Avoid running hooks when tangling.
  (let ((prog-mode-hook nil)
        (src  (expand-file-name "config.org" user-emacs-directory))
        (dest (expand-file-name "config.el"  user-emacs-directory)))
    (require 'ob-tangle)
    (org-babel-tangle-file src dest)
    (if (byte-compile-file dest)
        (byte-compile-dest-file dest)
      (with-current-buffer byte-compile-log-buffer
        (buffer-string)))))

(defun tangle-init ()
  "Tangle init.org asynchronously."

  (interactive)
  (message "Tangling init")
  (async-start
   (symbol-function #'tangle-init-sync)
   (lambda (result)
     (message "Init tangling completed: %s" result))))
#+END_SRC

* Key hints

** Which key

Emacs has 100s of bindings and it is impossible to remember them all. Sometimes I can remember the start of a key chord but not the entire one. [[https://github.com/justbur/emacs-which-key][Which-key]] is a package that gives you key hints on delay or if prompted. I really like it and use it extensively to setup the modal state.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :defer t
  :diminish which-key-mode
  :init
  (setq which-key-sort-order 'which-key-key-order-alpha)
  :bind* (("C-z ?" . which-key-show-top-level))
  :config
  (which-key-mode)
  (which-key-add-key-based-replacements
  "C-z ?" "top level bindings"))
#+END_SRC

** Discover my major

[[https://github.com/steckerhalter/discover-my-major][This package]] helps to discover the major mode bindings. I use it very occasionally and hence not binding it to any modal binding.

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
  :ensure t
  :bind (("C-h C-m" . discover-my-major)
         ("C-h M-m" . discover-my-mode)))
#+END_SRC

* Modal states

** Modalka mode

As mentioned before, I like and prefer modal editing. I feel pressing modifier keys all the time just leads to wrist pain and repetitive stress injuries. [[https://github.com/mrkkrp/modalka][Modalka]] is a package that is pretty simple and gives a platform for anyone to implement a modal mode. Let's call this state Modalka state and the normal Emacs way as Emacs state. This is also one of the core packages that I rely on. First, to load and configure some defaults.

#+BEGIN_SRC emacs-lisp
(use-package modalka
  :ensure t
  :demand t
  :diminish (modalka-mode . "μ")
  :init
  (setq modalka-cursor-type 'box)
  :config
  (global-set-key (kbd "<escape>") #'modalka-mode)
  (which-key-add-key-based-replacements
    "C-z" "Modalka prefix"
    "C-z :" "extended prefix"
    "C-z c" "code prefix"
    "C-z m" "multi-edit prefix"
    "C-z s" "smart nav prefix"
    "C-z SPC" "user prefix"
    "C-z g" "global prefix"
    "C-z i" "expand prefix"
    "C-z [" "prev nav prefix"
    "C-z ]" "next nav prefix"))
#+END_SRC

*** Default modal keybindings

These are modal bindings that just wrap around the existing, already bound, Emacs defaults.
The explanations for each can be found in the [[*Which%20key%20explanations%20for%20everything][corresponding which key explanations]].

**** Numbers

Pressing the numbers in Modalka state should trigger numbers and not insert them instead.

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "0" "C-0")
(modalka-define-kbd "1" "C-1")
(modalka-define-kbd "2" "C-2")
(modalka-define-kbd "3" "C-3")
(modalka-define-kbd "4" "C-4")
(modalka-define-kbd "5" "C-5")
(modalka-define-kbd "6" "C-6")
(modalka-define-kbd "7" "C-7")
(modalka-define-kbd "8" "C-8")
(modalka-define-kbd "9" "C-9")
#+END_SRC

**** Movement and one key presses

This is based on Vi-style but only slightly and uses the default movement keys in Emacs.

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "h" "C-b")
(modalka-define-kbd "j" "C-n")
(modalka-define-kbd "k" "C-p")
(modalka-define-kbd "l" "C-f")
(modalka-define-kbd "e" "M-f")
(modalka-define-kbd "b" "M-b")
(modalka-define-kbd "n" "M-n")
(modalka-define-kbd "N" "M-p")
(modalka-define-kbd "{" "M-{")
(modalka-define-kbd "}" "M-}")
(modalka-define-kbd "0" "C-a")
(modalka-define-kbd "$" "C-e")
(modalka-define-kbd "G" "M->")
(modalka-define-kbd "/" "C-s")
(modalka-define-kbd "y" "M-w")
(modalka-define-kbd "p" "C-y")
(modalka-define-kbd "P" "M-y")
(modalka-define-kbd "x" "C-d")
(modalka-define-kbd "D" "C-k")
(modalka-define-kbd "z" "C-l")
(modalka-define-kbd "!" "M-&")
(modalka-define-kbd "J" "C-v")
(modalka-define-kbd "K" "M-v")
(modalka-define-kbd "M" "C-u")
(modalka-define-kbd "I" "C-M-i")
(modalka-define-kbd "d" "C-S-w")
(modalka-define-kbd "H" "C-x <")
(modalka-define-kbd "L" "C-x >")
(modalka-define-kbd "Z" "C-x 1")
(modalka-define-kbd "q" "C-x (")
(modalka-define-kbd "Q" "C-x )")
(modalka-define-kbd "." "C-z .")
(modalka-define-kbd "?" "C-z ?")
(modalka-define-kbd "v" "C-SPC")
(modalka-define-kbd "=" "C-z =")
(modalka-define-kbd "R" "C-z R")
(modalka-define-kbd "X" "C-x C-x")
(modalka-define-kbd "+" "C-x r m")
(modalka-define-kbd "\\" "C-c C-c")
(modalka-define-kbd "V" "C-z V")
#+END_SRC

**** Global prefixed keys

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g g" "M-<")
(modalka-define-kbd "g o" "C-x C-e")
(modalka-define-kbd "g O" "C-z g O")
(modalka-define-kbd "g m" "C-z g m")
(modalka-define-kbd "g M" "C-z g M")
(modalka-define-kbd "g n" "C-z g n")
(modalka-define-kbd "g N" "C-z g N")
(modalka-define-kbd "g f" "C-z g f")
(modalka-define-kbd "g u" "C-z g u")
(modalka-define-kbd "g U" "C-z g U")
(modalka-define-kbd "g C" "C-z g C")
(modalka-define-kbd "g j" "C-z g j")
(modalka-define-kbd "g k" "C-z g k")
(modalka-define-kbd "g q" "C-z g q")
(modalka-define-kbd "g w" "C-x 3")
(modalka-define-kbd "g W" "C-x 2")
(modalka-define-kbd "g S" "C-j")
#+END_SRC

**** Select region prefixed keys

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "i a" "C-x h")
#+END_SRC

**** Forward navigation prefixed keys

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "] ]" "C-x n n")
(modalka-define-kbd "] s" "C-z ] s")
#+END_SRC

**** Backward navigation prefixed keys

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "[ [" "C-x n w")
#+END_SRC

**** Extended prefix to quit/restart and time

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd ": q" "C-x C-c")
(modalka-define-kbd ": r" "C-x M-c")
(modalka-define-kbd ": t" "C-z : t")
#+END_SRC

**** User prefix for common functions

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC j" "M-x")
(modalka-define-kbd "SPC x" "C-h f")
(modalka-define-kbd "SPC X" "C-h v")
(modalka-define-kbd "SPC ?" "C-h b")
(modalka-define-kbd "SPC a" "C-x b")
(modalka-define-kbd "SPC k" "C-x k")
(modalka-define-kbd "SPC d" "C-x d")
(modalka-define-kbd "SPC q" "C-x 0")
(modalka-define-kbd "SPC SPC" "C-s")
(modalka-define-kbd "SPC f" "C-x C-f")
(modalka-define-kbd "SPC w" "C-x C-s")
(modalka-define-kbd "SPC h" "C-c C-w")
(modalka-define-kbd "SPC o" "C-c C-k")
(modalka-define-kbd "SPC g" "C-c C-f")
(modalka-define-kbd "SPC c" "C-z SPC c")
#+END_SRC

*** Which key explanations for everything

I have added the which key explanations for everything at once because it is easier for me to look it up.

**** Numbers

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "0" "0"
  "1" "1"
  "2" "2"
  "3" "3"
  "4" "4"
  "5" "5"
  "6" "6"
  "7" "7"
  "8" "8"
  "9" "9")
#+END_SRC

**** Movement and one key presses

#+BEGIN_SRC emacs-lisp
  (which-key-add-key-based-replacements
    "ESC" "toggle mode"
    "DEL" "smart del"
    "TAB" "smart tab"
    "RET" "smart enter"
    "h" "prev char"
    "j" "next line"
    "k" "prev line"
    "l" "next char"
    "e" "next word"
    "b" "prev word"
    "n" "next history item"
    "N" "prev history item"
    "{" "next para"
    "}" "prev para"
    "0" "start of line"
    "$" "end of line"
    "(" "start of sentence"
    ")" "end of sentence"
    "G" "end of file"
    "/" "search"
    "d" "delete selection"
    "y" "copy selection"
    "p" "paste"
    "P" "paste history"
    "x" "delete char"
    "D" "delete rest of line"
    "I" "insert completion"
    "M" "modify argument"
    "z" "scroll center/top/bot"
    "Z" "zoom into window"
    "H" "scroll left"
    "J" "scroll down"
    "K" "scroll up"
    "L" "scroll right"
    "'" "org edit separately"
    "q" "start macro"
    "Q" "end macro"
    "." "repeat prev command"
    "?" "top level bindings"
    "v" "start selection"
    "R" "overwrite mode"
    "V" "start rectangle selection"
    "X" "exchange point and mark"
    "+" "set bookmark"
    "=" "indent region"
    "\\" "C-c C-c"
    "!" "async shell command"
    "&" "shell command")
#+END_SRC

**** Global prefixed keys

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g" "global prefix"
  "g g" "start of file"
  "g u" "downcase region"
  "g U" "upcase region"
  "g C" "capitalize region"
  "g m" "make frame"
  "g M" "delete frame"
  "g n" "select frame by name"
  "g N" "name frame"
  "g j" "next pdf page"
  "g k" "previous pdf page"
  "g f" "file/url at cursor"
  "g O" "edit all instances"
  "g o" "eval elisp"
  "g w" "vertical split win"
  "g W" "horizontal split win"
  "g S" "split line"
  "g q" "format para")
#+END_SRC

**** Select region prefixed keys

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "i" "expand prefix"
  "i a" "expand entire buffer")
#+END_SRC

**** Forward navigation prefixed keys

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "]" "forward nav/edit"
  "] ]" "narrow region"
  "] s" "next spell error")
#+END_SRC

**** Backward navigation prefixed keys

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "[" "backward nav/edit"
  "[ [" "widen region")
#+END_SRC

**** Extended prefix to quit/restart and time

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  ":" "extended prefix"
  ": q" "quit emacs"
  ": r" "restart emacs"
  ": t" "initiliazation time")
#+END_SRC

**** User prefix for common functions

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC" "custom prefix"
  "SPC x" "desc function"
  "SPC X" "desc variable"
  "SPC ?" "describe bindings"
  "SPC j" "jump to cmd"
  "SPC f" "find file"
  "SPC a" "switch buffers"
  "SPC d" "dired"
  "SPC k" "close buffer"
  "SPC w" "save buffer"
  "SPC c" "load theme"
  "SPC q" "quit window"
  "SPC h" "org refile"
  "SPC o" "over/abort"
  "SPC g" "follow"
  "SPC SPC" "search")
#+END_SRC

** Hydras

[[https://github.com/abo-abo/hydra][Hydra]] is not strictly a modal package but it is one that lets you define sticky bindings and I would call it semi-modal. I love it and need it. Currently, I don't define an hydras. They are defined under appropriate sections.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC

* Navigation

This section contains all the packages and custom functions I use for navigating within the buffer, within a project, in Emacs, etc. This is organized based on packages. Deleting the section of a package deletes the entire configuration surrounding it.

** Beacon mode

[[https://github.com/Malabarba/beacon][Beacon]] is just a tiny utility that indicates the cursor position when the cursor moves suddenly. You can also manually invoke it by calling the function =beacon-blink= and it is bound by default.

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :demand t
  :diminish beacon-mode
  :bind* (("C-z g i" . beacon-blink))
  :config
  (beacon-mode 1))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g i" "C-z g i")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g i" "blink cursor")
#+END_SRC

** Undo tree

The default Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Undo.html][undo]] command is weird. Better undo and redo states are given by [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]] mode and, as an added bonus, also gives a visualization tree

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :bind* (("C-z u" . undo-tree-undo)
          ("C-z r" . undo-tree-redo)
          ("C-z U" . undo-tree-visualize))
  :config
  (global-undo-tree-mode 1))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "u" "C-z u")
(modalka-define-kbd "U" "C-z U")
(modalka-define-kbd "r" "C-z r")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "u" "undo"
  "r" "redo"
  "U" "undo tree")
#+END_SRC

** Avy

[[https://github.com/abo-abo/avy][Avy]] is a package that lets you jump anywhere on screen based on character, characters, lines or words. It's one of my most used packages.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :init
  (setq avy-keys-alist
        `((avy-goto-char-2 . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))
          (avy-goto-char-in-line . (?j ?k ?l ?f ?s ?d))
          (avy-goto-line . (?j ?k ?l ?f ?s ?d ?e ?r ?u ?i))))
  (setq avy-style 'pre)
  :bind* (("C-z f" . avy-goto-char-in-line)
          ("C-z F" . avy-goto-line)
          ("C-z W" . avy-goto-char-2)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "f" "C-z f")
(modalka-define-kbd "F" "C-z F")
(modalka-define-kbd "W" "C-z W")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "f" "find in line"
  "F" "find line"
  "W" "find two chars")
#+END_SRC

** Highlight symbol

[[https://github.com/nschum/highlight-symbol.el][This package]] is pretty simple. It adds functionality to highlight the current word or symbol and navigate to other instances.

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :bind* (("C-z *" . highlight-symbol)
          ("C-z #" . highlight-symbol-occur)
          ("C-z g r" . highlight-symbol-remove-all))
  :config
  (highlight-symbol-nav-mode))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "*" "C-z *")
(modalka-define-kbd "#" "C-z #")
(modalka-define-kbd "g r" "C-z g r")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "*" "highlight symbol"
  "#" "list all highlights"
  "g r" "remove highlight")
#+END_SRC

** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] is a nice package for project navigation. It hijacks the =C-c p= prefix by default and you can learn more about its commands by pressing =C-c p= and waiting for which key to show hints.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :bind* (("C-z SPC d" . projectile-find-file)
          ("C-z SPC TAB" . projectile-find-other-file))
  :init
  (setq projectile-file-exists-remote-cache-expire (* 10 60))
  :diminish projectile-mode
  :config
  (projectile-global-mode))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC d" "C-z SPC d")
(modalka-define-kbd "SPC TAB" "C-z SPC TAB")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC d" "project files"
  "SPC TAB" "alternate file")
#+END_SRC

** Project wide search and replace

[[http://www.gnu.org/software/grep/manual/grep.html][grep]] and [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]] are the two standard programs to do a project wide search and replace. However, grep is pretty slow. I utilize faster alternatives like [[https://github.com/ggreer/the_silver_searcher][the silver searcher]] or [[https://github.com/monochromegane/the_platinum_searcher][the platinum searcher]] and therefore use their corresponding write-able grep versions.

#+BEGIN_SRC emacs-lisp
;; the silver searcher
(use-package ag
  :ensure t
  :bind* (("C-z g e" . ag-regexp))
  :config
  (use-package wgrep-ag
    :ensure t
    :bind* (("C-z g E" . wgrep-change-to-wgrep-mode))))

;; the platinum searcher
(use-package pt
  :ensure t
  :commands (pt-regexp)
  :bind* (("C-z g e" . pt-regexp))
  :config
  (use-package wgrep-pt
    :ensure t
    :commands (wgrep-change-to-wgrep-mode)
    :bind* (("C-z g E" . wgrep-change-to-wgrep-mode))))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g e" "C-z g e")
(modalka-define-kbd "g E" "C-z g E")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g e" "extract word in proj"
  "g E" "writable mode on")
#+END_SRC

** Ztree

[[https://github.com/fourier/ztree][ztree]] and its function =ztree-diff= is super useful when comparing directory trees.

#+BEGIN_SRC emacs-lisp
(use-package ztree
  :ensure t
  :bind* (("C-z g v" . ztree-dir)
          ("C-z g V" . ztree-diff))
  :init
  (setq ztree-dir-move-focus t))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g v" "C-z g v")
(modalka-define-kbd "g V" "C-z g V")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g v" "tree directory"
  "g V" "diff directories")
#+END_SRC

** Neotree

[[https://github.com/jaypei/emacs-neotree][Neotree]] is basically a directory drawer that is popular in all the modern text editors. I use it occasionally.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :bind* (("C-z SPC n". neotree-toggle))
  :init
  (setq neo-smart-open t))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC n" "C-c n")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC n" "directory tree")
#+END_SRC

** Tags based navigation

[[https://www.gnu.org/software/global/][GNU global]] is a code tagging system and I use it to navigate the code base. It can use different backends, including [[http://ctags.sourceforge.net][ctags]].

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :diminish ggtags-mode
  :bind* (("C-z T" . ggtags-find-tag-regexp)
          ("C-z g t" . ggtags-create-tags)
          ("C-z g T" . ggtags-update-tags))
  :init
  (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
  :config
  (add-hook 'prog-mode-hook 'ggtags-mode))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "T" "C-z T")
(modalka-define-kbd "g t" "C-z g t")
(modalka-define-kbd "g T" "C-z g T")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g t" "create tags"
  "g T" "update tags"
  "T" "global tags search")

#+END_SRC

** Perspective

[[https://github.com/nex3/perspective-el][Perspective]] creates different view ports in Emacs preserving the Window configuration. Super useful.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :bind* (("C-z C s" . persp-switch)
          ("C-z C a" . persp-add-buffer)
          ("C-z C A" . persp-set-buffer)
          ("C-z C b" . persp-switch-to-buffer)
          ("C-z C c" . persp-kill)
          ("C-z C r" . persp-rename)
          ("C-z C k" . persp-remove-buffer)
          ("C-z C n" . persp-next)
          ("C-z C p" . persp-prev)
          ("C-z C i" . persp-import)
          ("C-z C C" . persp-last))
  :config
  (persp-mode 1))
#+END_SRC

*** Which key binding explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "C-z C" "config perspective prefix")
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "C s" "C-z C s")
(modalka-define-kbd "C a" "C-z C a")
(modalka-define-kbd "C A" "C-z C A")
(modalka-define-kbd "C b" "C-z C b")
(modalka-define-kbd "C c" "C-z C c")
(modalka-define-kbd "C r" "C-z C r")
(modalka-define-kbd "C k" "C-z C k")
(modalka-define-kbd "C n" "C-z C n")
(modalka-define-kbd "C p" "C-z C p")
(modalka-define-kbd "C i" "C-z C i")
(modalka-define-kbd "C C" "C-z C C")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "C" "config persp prefix"
  "C s" "perspective switch"
  "C a" "perspective add buffer"
  "C A" "perspective set buffer"
  "C b" "perspective switch to buffer"
  "C c" "perspective close"
  "C r" "perspective rename"
  "C k" "perspective remove buffer"
  "C n" "perspective next"
  "C p" "perspective prev"
  "C i" "perspective import"
  "C C" "perspective last")
#+END_SRC

** Back button

The one thing I missed from Vim when I switched to Emacs was Vim's jump list. [[https://www.emacswiki.org/emacs/BackButton][Back button mode]] provides a similar navigation in Emacs where you navigate to the points where you made changes previously. Comes in really handy at times.

#+BEGIN_SRC emacs-lisp
(use-package back-button
  :ensure t
  :diminish back-button-mode
  :defer 2
  :init
  (setq back-button-show-toolbar-buttons nil)
  :bind* (("C-z ," . back-button-local-backward)
          ("C-z ;" . back-button-local-forward)
          ("C-z <" . back-button-global-backward)
          ("C-z >" . back-button-global-forward))
  :config
  (back-button-mode 1))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "," "C-z ,")
(modalka-define-kbd ";" "C-z ;")
(modalka-define-kbd ">" "C-z >")
(modalka-define-kbd "<" "C-z <")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "," "local backward"
  ";" "local forward"
  ">" "global forward"
  "<" "global backward")
#+END_SRC

** Custom functions

*** Open the =config.org= file

This function opens the current file when invoked from anywhere so that I can edit my configuration quickly, whenever I want

#+BEGIN_SRC emacs-lisp
(defun sk/open-config ()
  "Opens the configuration file from anywhere"
  (interactive)
  (find-file (concat user-emacs-directory "config.org")))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z SPC v" . sk/open-config))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC v" "C-z SPC v")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC v" "view configuration file")
#+END_SRC

*** Flyspell go to the previous spell error

[[*Manage%20the%20built-in%20flyspell%20mode][Flyspell]] mode offers only go to the next error by default. This is a custom function borrowed from Stack Overflow (I think) to do the opposite.

#+BEGIN_SRC emacs-lisp
;; Flyspell previous error
(defun sk/flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)

                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))

      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))

      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))
        (forward-word)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z [ s" . sk/flyspell-goto-previous-error))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "[ s" "C-z [ s")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "[ s" "previous spell error")
#+END_SRC

*** TODO Go to matching parenthesis, like Vi

Vi/Vim has a nice feature that jumps to the matching parenthesis/braces/brackets/tags when in one. This function emulates only the parenthesis part as of now. Should look into this once I learn more Emacs Lisp.

#+BEGIN_SRC emacs-lisp
(defun sk/goto-match-paren (arg)
  "Go to the matching parenthesis if on parenthesis, otherwise insert %.
vi style of % jumping to matching brace."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
        ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
        (t (self-insert-command (or arg 1)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z %" . sk/goto-match-paren))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "%" "C-z %")
#+END_SRC

Which key for modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "%" "goto matching paren")
#+END_SRC

*** Non native full screen

As mentioned [[*Fullscreen][here]], this is to further ensure that we use a non-native fullscreen.

#+BEGIN_SRC emacs-lisp
(defun sk/toggle-frame-fullscreen-non-native ()
  "Toggle full screen non-natively. Uses the `fullboth' frame paramerter
   rather than `fullscreen'. Useful to fullscreen on OSX w/o animations."
  (interactive)
  (modify-frame-parameters
   nil
   `((maximized
      . ,(unless (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
           (frame-parameter nil 'fullscreen)))
     (fullscreen
      . ,(if (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
             (if (eq (frame-parameter nil 'maximized) 'maximized)
                 'maximized)
           'fullboth)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z SPC z" . sk/toggle-frame-fullscreen-non-native))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC z" "C-z SPC z")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC z" "toggle fullscreen")
#+END_SRC

*** Split window and move

I hate the default Emacs behavior of split windows which just splits the window but doesn't go there.

#+BEGIN_SRC emacs-lisp
(defun sk/split-below-and-move ()
  (interactive)
  (split-window-below)
  (other-window 1))
(defun sk/split-right-and-move ()
  (interactive)
  (split-window-right)
  (other-window 1))
#+END_SRC

**** Key binding

This is one of the few occasions I just replace it with my custom function because I use it so much. Since the defaults of [[*Global%20prefixed%20keys][modalka]] and [[*Global%20prefixed%20keys][which-key]] already use and define this binding, there is no need for another one.

#+BEGIN_SRC emacs-lisp
(bind-keys
  ("C-x 2" . sk/split-below-and-move)
  ("C-x 3" . sk/split-right-and-move))
#+END_SRC

*** Turn the adjoining PDF

#+BEGIN_SRC emacs-lisp
(defun sk/other-pdf-next ()
  "Turns the next page in adjoining PDF file"
  (interactive)
  (other-window 1)
  (doc-view-next-page)
  (other-window 1))
(defun sk/other-pdf-previous ()
  "Turns the previous page in adjoining PDF file"
  (interactive)
  (other-window 1)
  (doc-view-previous-page)
  (other-window 1))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z ] d" . sk/other-pdf-next)
  ("C-z [ d" . sk/other-pdf-previous))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "] d" "C-z ] d")
(modalka-define-kbd "[ d" "C-z [ d")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "] d" "adjacent pdf next page"
  "[ d" "adjacent pdf prev page")
#+END_SRC

*** Smarter start of line

This function, from [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][emacsredux blog]], defines a better start of line and remaps =C-a= for it.

#+BEGIN_SRC emacs-lisp
(defun sk/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.
Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.
If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))
  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'sk/smarter-move-beginning-of-line)
#+END_SRC

*** Rotate the windows

[[https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el][Stolen]] from Magnar Sveen's configuration. This function is bound to the [[*Window%20navigation][hydra]] defined for window navigation.

#+BEGIN_SRC emacs-lisp
(defun sk/rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))
#+END_SRC

*** Open the current HTML file in browser

Not sure where I got this from. Most likely Magnar Sveen.

#+BEGIN_SRC emacs-lisp
(defun sk/browse-current-file ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g B" . sk/browse-current-file))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g B" "C-c v g B")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g B" "browse file in browser")
#+END_SRC

** Hydras

[[*Hydras][As described previously]], hydras are amazing sticky bindings and these are some that I use tons of time a day.

*** Window navigation

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-of-windows (:color red
                               :hint nil)
  "
 ^Move^    ^Size^    ^Change^                    ^Split^           ^Text^
 ^^^^^^^^^^^------------------------------------------------------------------
 ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   _u_: winner-undo _o_: rotate  _v_: vertical     _+_: zoom in
 _h_ ^+^ _l_   _H_ ^+^ _L_   _r_: winner-redo            _s_: horizontal   _-_: zoom out
 ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   _c_: close                  _z_: zoom         _q_: quit
"
  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)
  ("H" shrink-window-horizontally)
  ("K" shrink-window)
  ("J" enlarge-window)
  ("L" enlarge-window-horizontally)
  ("v" sk/split-right-and-move)
  ("s" sk/split-below-and-move)
  ("c" delete-window)
  ("f" sk/toggle-frame-fullscreen-non-native :color blue)
  ("o" sk/rotate-windows)
  ("z" delete-other-windows)
  ("u" (progn
         (winner-undo)
         (setq this-command 'winner-undo)))
  ("r" winner-redo)
  ("+" text-scale-increase)
  ("-" text-scale-decrease)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z w" . sk/hydra-of-windows/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "w" "C-z w")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "w" "window menu")
#+END_SRC

*** Bookmark navigation

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-bookmarks (:color blue
                              :hint nil)
  "
 _s_: set  _b_: bookmark   _j_: jump   _d_: delete   _q_: quit
  "
  ("s" bookmark-set)
  ("b" bookmark-save)
  ("j" bookmark-jump)
  ("d" bookmark-delete)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z '" . sk/hydra-bookmarks/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "'" "C-z '")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "'" "bookmark menu")
#+END_SRC

* Editing

This section lists all the custom functions and packages that help during any generic text editing.

** Expand region

[[https://github.com/magnars/expand-region.el][This]] is one of those packages I cannot imagine being without. Quickly expand semantically or directly to text/code with precision and change/delete/replace them.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind* (("C-z a" . er/expand-region)
          ("C-z A" . er/contract-region)
          ("C-z i p" . er/mark-text-paragraph)
          ("C-z i f" . er/mark-defun)
          ("C-z i w" . er/mark-word)
          ("C-z i u" . er/mark-url)
          ("C-z i t" . er/mark-LaTeX-math)
          ("C-z i c" . er/mark-comment)
          ("C-z i b" . er/mark-inside-pairs)
          ("C-z i q" . er/mark-inside-quotes)
          ("C-z i o" . er/mark-org-code-block)
          ("C-z i m" . er/mark-python-block)
          ("C-z i j" . er/mark-ruby-block-up)
          ("C-z i v" . er/mark-symbol)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "a" "C-z a")
(modalka-define-kbd "A" "C-z A")
(modalka-define-kbd "i p" "C-z i p")
(modalka-define-kbd "i f" "C-z i f")
(modalka-define-kbd "i w" "C-z i w")
(modalka-define-kbd "i u" "C-z i u")
(modalka-define-kbd "i t" "C-z i t")
(modalka-define-kbd "i c" "C-z i c")
(modalka-define-kbd "i b" "C-z i b")
(modalka-define-kbd "i q" "C-z i q")
(modalka-define-kbd "i o" "C-z i o")
(modalka-define-kbd "i m" "C-z i m")
(modalka-define-kbd "i j" "C-z i j")
(modalka-define-kbd "i v" "C-z i v")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "a" "expand region"
  "A" "contract region"
  "i" "expand region prefix"
  "i p" "expand in para"
  "i f" "expand in func"
  "i w" "expand in word"
  "i u" "expand in url"
  "i t" "expand in latex"
  "i c" "expand in comment"
  "i b" "expand in pair"
  "i q" "expand in quote"
  "i o" "expand in org code"
  "i m" "expand in python"
  "i j" "expand in julia"
  "i v" "expand in symbol")
#+END_SRC

** Commenting

[[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]] improves on the existing =comment-dwim= command for easy commenting. Pretty useful.

#+BEGIN_SRC emacs-lisp
(use-package comment-dwim-2
  :ensure t
  :bind* (("C-z g c" . comment-dwim-2)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g c" "C-z g c")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g c" "comment line/region")
#+END_SRC

** Smartparens

[[https://github.com/Fuco1/smartparens][This package]] aims to be the one-stop solution for semantic language in any language. It is a little hard to wrap your head around though. I mostly use it for its wrapping and unwrapping features more than semantic navigation. A caveat here is that, when trying to wrap a region with either parens/quotes/whatever, you need to exit OUT of modalka state to the Emacs state.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :demand t
  :bind* (("C-z s j" . sp-down-sexp)
          ("C-z s k" . sp-backward-up-sexp)
          ("C-z s h" . sp-backward-down-sexp)
          ("C-z s l" . sp-up-sexp)
          ("C-z s f" . sp-forward-sexp)
          ("C-z s b" . sp-backward-sexp)
          ("C-z s a" . sp-beginning-of-sexp)
          ("C-z s e" . sp-end-of-sexp)
          ("C-z s n" . sp-next-sexp)
          ("C-z s p" . sp-previous-sexp)
          ("C-z s >" . sp-forward-barf-sexp)
          ("C-z s <" . sp-backward-barf-sexp)
          ("C-z s )" . sp-forward-slurp-sexp)
          ("C-z s (" . sp-backward-slurp-sexp)
          ("C-z s x" . sp-transpose-sexp)
          ("C-z s d" . sp-kill-sexp)
          ("C-z s y" . sp-copy-sexp)
          ("C-z s u" . sp-unwrap-sexp)
          ("C-z s U" . sp-backward-unwrap-sexp)
          ("C-z s C" . sp-convolute-sexp)
          ("C-z s r" . sp-raise-sexp)
          ("C-z s s" . sp-split-sexp)
          ("C-z s S" . sp-splice-sexp)
          ("C-z s F" . sp-splice-sexp-killing-forward)
          ("C-z s B" . sp-splice-sexp-killing-backward)
          ("C-z s A" . sp-splice-sexp-killing-around))
  :diminish smartparens-mode
  :diminish smartparens-strict-mode
  :config
  (require 'smartparens-config)
  (smartparens-global-mode)
  (smartparens-global-strict-mode)
  (show-smartparens-global-mode)
  (which-key-add-key-based-replacements
    "C-z s" "smart nav prefix"))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "s j" "C-z s j")
(modalka-define-kbd "s k" "C-z s k")
(modalka-define-kbd "s h" "C-z s h")
(modalka-define-kbd "s l" "C-z s l")
(modalka-define-kbd "s f" "C-z s f")
(modalka-define-kbd "s b" "C-z s b")
(modalka-define-kbd "s a" "C-z s a")
(modalka-define-kbd "s e" "C-z s e")
(modalka-define-kbd "s n" "C-z s n")
(modalka-define-kbd "s p" "C-z s p")
(modalka-define-kbd "s >" "C-z s >")
(modalka-define-kbd "s <" "C-z s <")
(modalka-define-kbd "s )" "C-z s )")
(modalka-define-kbd "s (" "C-z s (")
(modalka-define-kbd "s x" "C-z s x")
(modalka-define-kbd "s d" "C-z s d")
(modalka-define-kbd "s y" "C-z s y")
(modalka-define-kbd "s u" "C-z s u")
(modalka-define-kbd "s U" "C-z s U")
(modalka-define-kbd "s U" "C-z s U")
(modalka-define-kbd "s U" "C-z s U")
(modalka-define-kbd "s C" "C-z s C")
(modalka-define-kbd "s r" "C-z s r")
(modalka-define-kbd "s s" "C-z s s")
(modalka-define-kbd "s S" "C-z s S")
(modalka-define-kbd "s F" "C-z s F")
(modalka-define-kbd "s B" "C-z s B")
(modalka-define-kbd "s A" "C-z s A")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "s" "smart nav prefix"
  "s >" "forward prefix"
  "s <" "backward prefix"
  "s j" "smart down"
  "s k" "smart backward up"
  "s h" "smart backward down"
  "s l" "smart up"
  "s f" "smart forward"
  "s b" "smart backward"
  "s a" "smart beginning"
  "s e" "smart end"
  "s n" "smart next"
  "s p" "smart previous"
  "s >" "expression forward barf"
  "s <" "expression backward barf"
  "s )" "expression forward slurp"
  "s (" "expression backward slurp"
  "s x" "smart transpose"
  "s d" "smart delete"
  "s y" "smart copy"
  "s u" "selection unwrap"
  "s U" "backward unwrap"
  "s C" "convolute sexp"
  "s r" "raise sexp"
  "s s" "split sexp"
  "s S" "splice sexp"
  "s F" "splice forward"
  "s B" "splice backward"
  "s A" "splice around")
#+END_SRC

** Interactive edit

[[https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer][Iedit-mode]] is the bomb. Quick, fast edits of every symbol selected. Although [[*Multiple cursors][multiple cursors]] has some more features, this is the best choice for quick renaming of variables/words.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :ensure t
  :commands (iedit-mode)
  :bind* (("C-z m i" . iedit-mode)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "m i" "C-z m i")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "m i" "multi interactive edit ")
#+END_SRC

** Multiple cursors

This is one of those packages which is great when it works and frustrating when it is not because [[https://github.com/magnars/multiple-cursors.el][it is essentially crazy functionality]]. Note that, this also has the same caveat as that of Smartparens wrapping - invoke the keys once you are OUT of modalka state, in normal emacs region state. To aid this, [[*Region bindings mode][Region bindings mode]] bindings are setup.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind* (("C-z m e" . mc/edit-beginnings-of-lines)
            ("C-z m E" . mc/edit-ends-of-lines)
            ("C-z m a" . mc/mark-all-like-this)
            ("C-z m f" . mc/mark-next-like-this)
            ("C-z m F" . mc/mark-previous-like-this)
            ("C-z m m" . mc/mark-more-like-this-extended)
            ("C-z m s" . mc/skip-to-next-like-this)
            ("C-z m S" . mc/skip-to-previous-like-this)
            ("C-z m n" . mc/insert-numbers)
            ("C-z m l" . mc/insert-letters)
            ("C-z m d" . mc/mark-all-like-this-in-defun)))
#+END_SRC

*** Modal binding

Note that triggering multiple cursors when in modalka state is most likely to break it. This is just for reference. The bindings need to be invoked as indicated in [[*Region bindings mode][region bindings mode]].

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "m e" "C-z m e")
(modalka-define-kbd "m E" "C-z m E")
(modalka-define-kbd "m a" "C-z m a")
(modalka-define-kbd "m f" "C-z m f")
(modalka-define-kbd "m F" "C-z m F")
(modalka-define-kbd "m m" "C-z m m")
(modalka-define-kbd "m s" "C-z m s")
(modalka-define-kbd "m S" "C-z m S")
(modalka-define-kbd "m n" "C-z m n")
(modalka-define-kbd "m l" "C-z m l")
(modalka-define-kbd "m d" "C-z m d")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "m" "multiple cursor prefix"
  "m a" "mark all similar selection"
  "m F" "mark prev similar selection"
  "m f" "mark next similar selection"
  "m S" "skip prev similar selection"
  "m s" "skip next similar selection"
  "m m" "extend similar selection"
  "m e" "edit start of selection"
  "m E" "edit end of selection"
  "m n" "insert numbers"
  "m l" "insert letters"
  "m d" "mark all in function")
#+END_SRC

** TODO Region bindings mode

This a special mode, sort of modal state, that is triggered ONLY when some region is selected. To use these bindings, move OUT of modalka state and press them in Emacs state. I use it primarily for [[*Multiple cursors][multiple cursors]] but it can be configured to be used for anything. In the future, I'm planning to set up a little more Vim-ish setup by faking operators, etc in the normal mode while they can have separate meanings in =region-bindings= mode. Let's see.

#+BEGIN_SRC emacs-lisp
  (use-package region-bindings-mode
    :ensure t
    :demand t
    :bind (:map region-bindings-mode-map
                ("ma" . mc/mark-all-like-this)
                ("mb" . mc/mark-previous-like-this)
                ("mf" . mc/mark-next-like-this)
                ("mS" . mc/skip-to-previous-like-this)
                ("ms" . mc/skip-to-next-like-this)
                ("mm" . mc/mark-more-like-this-extended)
                ("me" . mc/edit-beginnings-of-lines)
                ("mE" . mc/edit-ends-of-lines)
                ("mn" . mc/insert-numbers)
                ("ml" . mc/insert-letters)
                ("md" . mc/mark-all-like-this-in-defun))
    :diminish (region-bindings-mode . "ρ")
    :config
    (region-bindings-mode-enable))
#+END_SRC

** Visual replace

This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives such as [[*Interactive edit][iedit]] and [[*Multiple cursors][multiple cursors]]. You search for a word in the buffer/region, type in the replacement and confirm each one by pressing =y= or =n= or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure t
  :commands (vr/query-replace)
  :bind* (("C-z SPC s" . vr/query-replace))
  :config
  (use-package visual-regexp-steroids
    :ensure t
    :commands (vr/select-query-replace)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC s" "C-z SPC s")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC s" "replace word/expression")
#+END_SRC

** Snippets

[[https://github.com/capitaomorte/yasnippet][Yasnippets]] gives you the snippets functionality. It also comes bundled with a lot of pre-configured snippets and is extensible via Emacs Lisp.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :commands (yas-insert-snippet yas-new-snippet)
  :bind* (("C-z S" . yas-insert-snippet))
  :init
  (setq yas-prompt-functions '(yas-completing-prompt))
  :diminish (yas-minor-mode . "γ")
  :config
  (yas-global-mode))
#+END_SRC

Also, I don't want to trigger snippets when I'm in shell. So, let's turn it off.

#+BEGIN_SRC emacs-lisp
(defun sk/force-yasnippet-off ()
  (yas-minor-mode -1)
  (setq yas-dont-activate t))
(add-hook 'term-mode-hook 'sk/force-yasnippet-off)
(add-hook 'shell-mode-hook 'sk/force-yasnippet-off)
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "S" "C-z S")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "S" "snippets")
#+END_SRC

** Custom functions

*** Insert date or date and time

This function is to easily insert date or datetime in the current buffer.

#+BEGIN_SRC emacs-lisp
(defun sk/insert-date (prefix)
  "Insert the current date. With prefix-argument, use British format. With
   two prefix arguments, write out the day and month name."
  (interactive "P")
  (let ((format (cond
                 ((not prefix) "%Y-%m-%d")
                 ((equal prefix '(4)) "%d/%m/%Y")
                 ((equal prefix '(16)) "%A, %d %B %Y"))))
    (insert (format-time-string format))))

(defun sk/insert-datetime (prefix)
  "Insert the current date and time."
  (interactive "P")
  (let ((format (cond
                 ((not prefix) "%Y-%m-%d %H:%M:%S")
                 ((equal prefix '(4)) "%Y-%m-%dT%H:%M:%SZ"))))
    (insert (format-time-string format))))
#+END_SRC

*** Rename the current buffer and the file associated with it

[[https://github.com/magnars/.emacs.d/blob/master/defuns/file-defuns.el][Stolen]] from Magnar Sveen's config.

#+BEGIN_SRC emacs-lisp
(defun sk/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g R" . sk/rename-current-buffer-file))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g R" "C-z g R")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g R" "rename buffer and file")
#+END_SRC

*** Delete the current buffer and the file associated with it

[[https://github.com/magnars/.emacs.d/blob/master/defuns/file-defuns.el][Stolen]] from Magnar Sveen's config.

#+BEGIN_SRC emacs-lisp
(defun sk/delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g K" . sk/delete-current-buffer-file))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g K" "C-z g K")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g K" "delete buffer and file")
#+END_SRC

*** Copy the current file path

Get the file path of the current file.

#+BEGIN_SRC emacs-lisp
  (defun sk/copy-current-file-path ()
    "Add current file path to kill ring. Limits the filename to project root if possible."
    (interactive)
    (kill-new buffer-file-name))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g y" . sk/copy-current-file-path))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g y" "C-z g y")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g y" "copy current file path")
#+END_SRC

*** Transposing words

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Transpose.html][Transpose]] is a built-in functionality to exchange words/characters/functions. I just build wrapper functions around it to make it exchange it the way I want it to.

#+BEGIN_SRC emacs-lisp
;; Transpose words forward
(defun sk/transpose-words-forward ()
  "Transpose words forward"
  (interactive)
  (forward-word 1)
  (forward-char 1)
  (transpose-words 1)
  (backward-word 1))
;; Transpose words backward
(defun sk/transpose-words-backward ()
  "Transpose words backward"
  (interactive)
  (transpose-words 1)
  (backward-word 1))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z [ w" . sk/transpose-words-backward)
  ("C-z ] w" . sk/transpose-words-forward))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "[ w" "C-z [ w")
(modalka-define-kbd "] w" "C-z ] w")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "[ w" "exchange with prev word"
  "] w" "exchange with next word")
#+END_SRC

*** Transposing characters

Though this is used much less that [[*Transposing words][transposing words]], it is still useful.

#+BEGIN_SRC emacs-lisp
;; Transpose chars forward
(defun sk/transpose-chars-forward ()
  "Transpose chars forward"
  (interactive)
  (forward-char 1)
  (transpose-chars 1)
  (backward-char 1))
;; Transpose chars backward
(defun sk/transpose-chars-backward ()
  "Transpose chars backward"
  (interactive)
  (transpose-chars 1)
  (backward-char 1))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z [ c" . sk/transpose-chars-backward)
  ("C-z ] c" . sk/transpose-chars-forward))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "[ c" "C-z [ c")
(modalka-define-kbd "] c" "C-z ] c")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "[ c" "exchange with prev char"
  "] c" "exchange with next char")
#+END_SRC

*** Copy to the end of the line

We already have delete to the end of line (pressing =C-k=). It is only natural there has to be copy too.

#+BEGIN_SRC emacs-lisp
(defun sk/copy-to-end-of-line ()
  (interactive)
  (kill-ring-save (point)
                  (line-end-position))
  (message "Copied to end of line"))
#+END_SRC

**** Keybinding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z Y" . sk/copy-to-end-of-line))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "Y" "C-z y")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "Y" "copy till end of line")
#+END_SRC

*** Duplicate

Duplicate the selected region.

#+BEGIN_SRC emacs-lisp
(defun sk/duplicate-region (&optional num start end)
  "Duplicates the region bounded by START and END NUM times.
If no START and END is provided, the current region-beginning and
region-end is used."
  (interactive "p")
  (save-excursion
    (let* ((start (or start (region-beginning)))
           (end (or end (region-end)))
           (region (buffer-substring start end)))
      (goto-char end)
      (dotimes (i num)
        (insert region)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g D" . sk/duplicate-region))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g D" "C-z g D")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g D" "duplicate region")
#+END_SRC

*** Open line

The built-in command for open-line (triggered by =C-o=) is weird. I prefer Vi style opening of lines. This creates a new line either above or below accordingly and puts you there. I open lines above more than below and hence, prefer that to be a single-key binding.

#+BEGIN_SRC emacs-lisp
;; Open line above
(defun sk/open-line-above ()
  "Insert a newline above the current line and put point at beginning."
  (interactive)
  (unless (bolp)
    (beginning-of-line))
  (newline)
  (forward-line -1)
  (indent-according-to-mode))
#+END_SRC

**** Key binding

This is also one of the few cases where I bind a function to the defaults. I feel this is sensible enough that it has to be the default ([[*Split window and move][like window splitting]]).

#+BEGIN_SRC emacs-lisp
(bind-keys
  ("C-o" . sk/open-line-above))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "O" "C-o")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "O" "open line above")
#+END_SRC

*** Join line

I use =electric-newline-and-maybe-indent= as a substitute for splitting lines. Of course, I would want something to join them.

#+BEGIN_SRC emacs-lisp
(defun sk/join-line ()
  "Join the current line with the next line"
  (interactive)
  (next-line)
  (delete-indentation))
#+END_SRC

**** Key binding

I bind this to =C-S-j= since =C-j= is the key to split a line.

#+BEGIN_SRC emacs-lisp
(bind-keys
  ("C-S-j" . sk/join-line))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g J" "C-S-j")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g J" "join line")
#+END_SRC

*** Select the current line

[[*Expand region][Expand region]] is pretty good but sometimes, I want to select the current line and this function takes care of that. Also note that this depends on [[*Smarter start of line][smarter start of line]] to select the line.

#+BEGIN_SRC emacs-lisp
(defun sk/select-current-line ()
  "Select the current line"
  (interactive)
  (sk/smarter-move-beginning-of-line 1)
  (set-mark (line-end-position)))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z i l" . sk/select-current-line))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "i l" "C-z i l")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "i l" "select current line")
#+END_SRC

*** Correct those annoying DOuble capitals

I am not great at typing and I make [[*Add for auto correction][plenty of mistakes]]. I especially hate that double characters. I found this on [[http://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type/13975#13975][Stack overflow]] and just had to put it in my config. First, a function to detect and correct it.

#+BEGIN_SRC emacs-lisp
(defun sk/dcaps-to-scaps ()
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (and (= ?w (char-syntax (char-before)))
       (save-excursion
         (and (if (called-interactively-p)
                  (skip-syntax-backward "w")
                (= -3 (skip-syntax-backward "w")))
              (let (case-fold-search)
                (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
              (capitalize-word 1)))))
#+END_SRC

Then, let's define a minor mode for it to be activated.

#+BEGIN_SRC emacs-lisp
(define-minor-mode sk/dubcaps-mode
  "Toggle `sk/dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter (" DC")
  (if sk/dubcaps-mode
      (add-hook 'post-self-insert-hook #'sk/dcaps-to-scaps nil 'local)
    (remove-hook 'post-self-insert-hook #'sk/dcaps-to-scaps 'local)))
#+END_SRC

Finally, let's add a hook so that it is on for all the text files Emacs opens.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook #'sk/dubcaps-mode)
#+END_SRC

Also, since we add a minor mode string (it might be useful sometimes), currently I prefer to diminish it.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-dubcaps ()
  (interactive)
  (diminish 'sk/dubcaps-mode ""))
(add-hook 'sk/dubcaps-mode-hook 'sk/diminish-dubcaps)
#+END_SRC

*** Move lines

I adapted this from the [[https://www.emacswiki.org/emacs/move-text.el][Emacs wiki]] entry about the same thing. This will move a line up or down and also a region if the region is selected. While selecting a region, make sure you select the newline character for best results. First to define the core function that makes this happen.

#+BEGIN_SRC emacs-lisp
(defun sk/move-text-internal (arg)
  (cond
   ((and mark-active transient-mark-mode)
    (if (> (point) (mark))
        (exchange-point-and-mark))
    (let ((column (current-column))
          (text (delete-and-extract-region (point) (mark))))
      (forward-line arg)
      (move-to-column column t)
      (set-mark (point))
      (insert text)
      (exchange-point-and-mark)
      (setq deactivate-mark nil)))
   (t
    (let ((column (current-column)))
      (beginning-of-line)
      (when (or (> arg 0) (not (bobp)))
        (forward-line)
        (when (or (< arg 0) (not (eobp)))
          (transpose-lines arg)
          (when (and (eval-when-compile
                       '(and (>= emacs-major-version 24)
                             (>= emacs-minor-version 3)))
                     (< arg 0))
            (forward-line -1)))
        (forward-line -1))
      (move-to-column column t)))))
#+END_SRC

Now, let's define wrapper functions which we bind

#+BEGIN_SRC emacs-lisp
(defun sk/move-text-down (arg)
  "Move region (transient-mark-mode active) or current line
  arg lines down."
  (interactive "*p")
  (sk/move-text-internal arg))
(defun sk/move-text-up (arg)
  "Move region (transient-mark-mode active) or current line
  arg lines up."
  (interactive "*p")
  (sk/move-text-internal (- arg)))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z [ e" . sk/move-text-up)
  ("C-z ] e" . sk/move-text-down))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "[ e" "C-z [ e")
(modalka-define-kbd "] e" "C-z ] e")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "[ e" "move text up"
  "] e" "move text down")
#+END_SRC

*** Change from snake case to camel case

=snake_case= and =camelCase= are common ways to write variable names and this function helps to convert one to the other. [[https://github.com/magnars/.emacs.d/blob/master/defuns/editing-defuns.el][Stolen]] from Magnar Sveen's configuration.

#+BEGIN_SRC emacs-lisp
(defun sk/replace-next-underscore-with-camel (arg)
  (interactive "p")
  (if (> arg 0)
      (setq arg (1+ arg))) ; 1-based index to get eternal loop with 0
  (let ((case-fold-search nil))
    (while (not (= arg 1))
      (search-forward-regexp "\\b_[a-z]")
      (forward-char -2)
      (delete-char 1)
      (capitalize-word 1)
      (setq arg (1- arg)))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g +" . sk/replace-next-underscore-with-camel))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g +" "C-z g +")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g +" "camelCase word")
#+END_SRC

*** Make current word snake case

Works just like the [[*Change from snake case to camel case][previous case]]. Note that this depends on [[*Expand region][Expand region]]. Also, Magnar's config.

#+BEGIN_SRC emacs-lisp
(defun sk/snakeify-current-word ()
  (interactive)
  (er/mark-word)
  (let* ((beg (region-beginning))
         (end (region-end))
         (current-word (buffer-substring-no-properties beg end))
         (snakified (snake-case current-word)))
    (replace-string current-word snakified nil beg end)))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g _" . sk/snakeify-current-word))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g _" "C-z g _")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g _" "snake_case word")
#+END_SRC

*** Kebab case current word

=kebab-case= is how almost all Emacs Lisp functions/variables are written. It is useful to have this. Note that this also depends on [[*Expand region][Expand region]]. Also stolen from Magnar's config. The man has so many useful functions!

#+BEGIN_SRC emacs-lisp
(defun sk/kebab-current-word ()
  (interactive)
  (er/mark-word)
  (let* ((beg (region-beginning))
         (end (region-end))
         (current-word (buffer-substring-no-properties beg end))
         (kebabed (s-dashed-words current-word)))
    (replace-string current-word kebabed nil beg end)))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g -" . sk/kebab-current-word))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g -" "C-z g -")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g -" "kebab-case word")
#+END_SRC

*** Transpose paranthesis

This function was something I missed when I was using Vim with the [[https://github.com/tpope/vim-surround][vim-surround]] plugin. This helps to change the kind of paranthesis. Toggle between pairs of "()", "[]" and "{}". First let's put a couple of functions that this depends on.

#+BEGIN_SRC emacs-lisp
(defun move-forward-out-of-param ()
  (while (not (looking-at ")\\|, \\| ?}\\| ?\\]"))
    (cond
     ((point-is-in-string-p) (move-point-forward-out-of-string))
     ((looking-at "(\\|{\\|\\[") (forward-list))
     (t (forward-char)))))

(defun move-backward-out-of-param ()
  (while (not (looking-back "(\\|, \\|{ ?\\|\\[ ?"))
    (cond
     ((point-is-in-string-p) (move-point-backward-out-of-string))
     ((looking-back ")\\|}\\|\\]") (backward-list))
     (t (backward-char)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun transpose-params ()
  "Presumes that params are in the form (p, p, p) or {p, p, p} or [p, p, p]"
  (interactive)
  (let* ((end-of-first (cond
                        ((looking-at ", ") (point))
                        ((and (looking-back ",") (looking-at " ")) (- (point) 1))
                        ((looking-back ", ") (- (point) 2))
                        (t (error "Place point between params to transpose."))))
         (start-of-first (save-excursion
                           (goto-char end-of-first)
                           (move-backward-out-of-param)
                           (point)))
         (start-of-last (+ end-of-first 2))
         (end-of-last (save-excursion
                        (goto-char start-of-last)
                        (move-forward-out-of-param)
                        (point))))
    (transpose-regions start-of-first end-of-first start-of-last end-of-last)))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z s c" . transpose-params))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "s c" "C-z s c")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "s c" "change surroundings")
#+END_SRC

*** Toggle quotes

Some languages are finicky about single quotes or double quotes. This helps me toggle between the two. Also, thanks to Magnar. First, to define some helper functions.

#+BEGIN_SRC emacs-lisp
(defun sk/current-quotes-char ()
  (nth 3 (syntax-ppss)))

(defalias 'point-is-in-string-p 'sk/current-quotes-char)

(defun sk/move-point-forward-out-of-string ()
  (while (point-is-in-string-p) (forward-char)))

(defun sk/move-point-backward-out-of-string ()
  (while (point-is-in-string-p) (backward-char)))

(defun sk/alternate-quotes-char ()
  (if (eq ?' (sk/current-quotes-char)) ?\" ?'))
#+END_SRC

Now, for the function that wraps all these and gives the actual functionality.

#+BEGIN_SRC emacs-lisp
(defun sk/toggle-quotes ()
  (interactive)
  (if (point-is-in-string-p)
      (let ((old-quotes (char-to-string (sk/current-quotes-char)))
            (new-quotes (char-to-string (sk/alternate-quotes-char)))
            (start (make-marker))
            (end (make-marker)))
        (save-excursion
          (sk/move-point-forward-out-of-string)
          (backward-delete-char 1)
          (set-marker end (point))
          (insert new-quotes)
          (sk/move-point-backward-out-of-string)
          (delete-char 1)
          (insert new-quotes)
          (set-marker start (point))
          (replace-string new-quotes (concat "\\" new-quotes) nil start end)
          (replace-string (concat "\\" old-quotes) old-quotes nil start end)))
    (error "Point isn't in a string")))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z s q" . sk/toggle-quotes))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "s q" "C-z s q")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "s q" "switch quotes")
#+END_SRC

*** Add for auto correction

This function was taken from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][endless paranthesis]] post on auto-correction. Note that to use this, you obviously have to have [[*Manage the built-in flyspell mode][flyspell mode]] enabled in the buffer.

#+BEGIN_SRC emacs-lisp
(defun sk/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))
(defun sk/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (sk/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (sk/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g =" . sk/ispell-word-then-abbrev))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g =" "C-z g =")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g =" "autocorrect word")
#+END_SRC

** Hydras

*** Rectangle edit mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Rectangles.html][Rectangle edit mode]] is one of the unique features of Emacs (and Vim) and this hydra makes it easier to interact with it.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-rectangle (:color red
                              :hint nil)
  "
 _p_: paste   _c_: clear    _r_: replace
 _y_: copy    _o_: open     _i_: insert
 _d_: kill    _n_: number   _q_: quit
"
  ("h" backward-char nil)
  ("l" forward-char nil)
  ("k" previous-line nil)
  ("j" next-line nil)
  ("y" copy-rectangle-as-kill)
  ("d" kill-rectangle nil)
  ("c" clear-rectangle nil)
  ("o" open-rectangle nil)
  ("p" yank-rectangle)
  ("r" string-rectangle)
  ("i" string-insert-rectangle)
  ("n" rectangle-number-lines)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z E" . sk/hydra-rectangle/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "E" "C-z E")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "E" "edit rectangle region")
#+END_SRC

*** Macros

[[https://www.emacswiki.org/emacs/KeyboardMacros][Macros]] are awesome too! It's a little complicated to wrap your head around first but I'm very used to it from my Vim days and cannot live without it.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-of-macros (:color red
                              :hint nil)
  "
 _m_: macro  _l_: lossage  _v_: view      _f_: forward    _d_: delete   _q_: quit
 _p_: prev   _e_: edit     _r_: register  _b_: backward   _k_: key
  "
  ("m" kmacro-call-macro)
  ("p" kmacro-call-ring-2nd)
  ("l" kmacro-edit-lossage :color blue)
  ("e" kmacro-edit-macro :color blue)
  ("v" kmacro-view-macro :color blue)
  ("r" kmacro-to-register :color blue)
  ("f" kmacro-cycle-ring-next)
  ("b" kmacro-cycle-ring-previous)
  ("d" kmacro-delete-ring-head :color blue)
  ("k" kmacro-bind-to-key :color blue)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z @" . sk/hydra-of-macros/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "@" "C-z @")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "@" "macros menu")
#+END_SRC

*** Registers

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Registers.html][Registers]] are one of my under-used features but it's still nice to have around though.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-registers (:color blue
                              :hint nil)
  "
 _a_: append     _c_: copy-to    _j_: jump       _r_: rectangle-copy   _q_: quit
 _i_: insert     _n_: number-to  _f_: frameset   _w_: window-config
 _+_: increment  _p_: point-to
  "
  ("a" append-to-register)
  ("c" copy-to-register)
  ("i" insert-register)
  ("f" frameset-to-register)
  ("j" jump-to-register)
  ("n" number-to-register)
  ("r" copy-rectangle-to-register)
  ("w" window-configuration-to-register)
  ("+" increment-register)
  ("p" point-to-register)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
 ("C-z \"" . sk/hydra-registers/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "\"" "C-z \"")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "\"" "registers")
#+END_SRC

* Visual

This section adds some packages which enhance visual feedback and mostly work behind the scenes to get stuff done.

** Volatile highlights

I particularly like this [[https://github.com/k-talo/volatile-highlights.el][package]]. It gives visual feedback on some of the common operations like undo, copying and pasting and also inherits the color scheme very well.

#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :demand t
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t))
#+END_SRC

** Column enforce mode

Just like the previous package, [[https://github.com/jordonbiondo/column-enforce-mode][this one]] is also subtle. It highlights characters that exceed a particular column margin. Very useful while coding.

#+BEGIN_SRC emacs-lisp
(use-package column-enforce-mode
  :ensure t
  :diminish column-enforce-mode
  :init
  (setq column-enforce-column 99)
  :config
  (progn
    (add-hook 'prog-mode-hook 'column-enforce-mode)))
#+END_SRC

** Highlight indentation

Languages like Python and rarely even huge functions in C/C++ are indented and it's hard to judge it's scope. That's when [[https://github.com/antonj/Highlight-Indentation-for-Emacs][this package]] becomes particularly useful. I never leave this on. I always turn it on and the off pretty soon.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indentation
  :ensure t
  :commands (highlight-indentation-mode))
#+END_SRC

** Fill column indicator

[[https://www.emacswiki.org/emacs/FillColumnIndicator][This]] package is similar to [[*Column enforce mode][Column enforce mode]] but adds a line as a margin instead of being subtle. I make sure my code has a soft limit of 80 characters per line and a hard limit of 100 characters per line. Therefore I enable this for 80 characters and column enforce mode for 100.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :commands (fci-mode)
  :init
  (setq fci-rule-width 5
        fci-rule-column 79))
#+END_SRC

** White space butler

The improvement [[https://github.com/lewang/ws-butler][this package]] provides over the built-in =delete-trailing-whitespace= is that this deletes whitespace from changes that only /I/ made.

#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :ensure t
  :diminish ws-butler-mode
  :config
  (ws-butler-global-mode))
#+END_SRC

** Region state

This is a fairly simple [[https://github.com/xuchunyang/region-state.el][package]] that provides information about the active region.

#+BEGIN_SRC emacs-lisp
(use-package region-state
  :ensure t
  :config
  (region-state-mode))
#+END_SRC

** Color themes

Of course we need color themes. I like the [[https://github.com/purcell/color-theme-sanityinc-tomorrow][sanityinc tomorrow]] color themes. They have night, dark, eighties and blue version, all of which are nice. That's the only one I'm including.

#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
  :ensure t
  :config
  (progn
    (load-theme 'sanityinc-tomorrow-eighties t)))
#+END_SRC

** Mode line

[[https://github.com/TheBB/spaceline][Spaceline]] is similar to the [[http://spacemacs.org][Spacemacs]] mode-line. I like it. It's pretty cool.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :demand t
  :init
  (setq powerline-default-separator 'arrow-fade)
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme))
#+END_SRC

** Fancy battery status

I'm on Emacs full screen most of the day and battery status would sure be helpful. While, Emacs has a built-in =display-battery-mode= but why not go [[https://github.com/lunaryorn/fancy-battery.el][fancy]].

#+BEGIN_SRC emacs-lisp
(use-package fancy-battery
  :ensure t
  :init
  (setq fancy-battery-show-percentage t)
  :config
  (fancy-battery-mode))
#+END_SRC

** Weather

And while we are it, why not go ahead and [[https://github.com/bcbcarl/emacs-wttrin][get some weather status too]].

#+BEGIN_SRC emacs-lisp
(use-package wttrin
  :ensure t
  :commands (wttrin)
  :init
  (setq wttrin-default-cities '("Gainesville"
                                "Albuquerque"
                                "Chennai"
                                "Hyderabad"
                                "Columbus"
                                "Hillsboro")))
#+END_SRC

** Origami - folding based on indentation/syntax

Emacs has a built-in =hide-show= mode but it isn't great. [[https://github.com/gregsexton/origami.el][Origami]] improves it a bit.

#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :commands (origami-toggle-node)
  :bind* (("C-z |" . orgiami-toggle-node)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "|" "C-z |")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
    "|" "syntax-based fold toggle")
#+END_SRC

** Vimish fold - Fold regions based on selection

Syntax based folding is great and all but sometimes I need to fold some random piece of text and [[https://github.com/mrkkrp/vimish-fold][Vimish fold]] is good for that.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :ensure t
  :commands (vimish-fold-toggle
             vimish-fold))
#+END_SRC

** Hydras

*** Activate minor modes

There are many minor modes that I don't need to be active all the time. And this hydra activates them on my command. It also has a button to activate the package menu based on
[[*Improve the built-in package menu][paradox]].

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-of-activate (:color blue
                                :hint nil)
  "
 _b_: battery   _n_: number       _v_: wrap        _c_: column    _i_: indent        _k_: which-key   _l_: talk       _q_: quit
 _t_: time      _w_: weather      _y_: yasnippet   _m_: margin    _s_: smartparens   _o_: org extras  _j_: jabber
 _f_: flyspell  _a_: auto-comp    _d_: fold        _g_: ggtags    _p_: paradox       _e_: error       _h_: html emmet
"
  ("b" fancy-battery-mode :color red)
  ("t" display-time-mode :color red)
  ("n" linum-mode :color red)
  ("w" wttrin)
  ("f" flyspell-mode)
  ("v" visual-line-mode)
  ("p" paradox-list-packages)
  ("c" column-enforce-mode)
  ("y" yas-global-mode)
  ("a" company-mode)
  ("i" highlight-indentation-mode)
  ("m" fci-mode :color red)
  ("j" jabber-connect :color red)
  ("l" jabber-chat-with)
  ("o" sk/org-custom-load :color blue)
  ("g" ggtags-mode)
  ("d" global-origami-mode)
  ("k" which-key-mode)
  ("s" smartparens-strict-mode)
  ("h" emmet-mode)
  ("e" global-flycheck-mode)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g a" . sk/hydra-of-activate/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g a" "C-z g a")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g a" "global activate modes")
#+END_SRC

*** Vimish fold

Vimish fold has all these fancy features and I use it much more than Origami. Let's make a hydra for that.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-vimish-fold (:color red
                                :hint nil)
  "
 _f_: fold  _u_: unfold  _r_: refold  _t_: toggle  _d_: delete    _n_: next      _q_: quit
          _U_: Unfold  _R_: Refold  _T_: Toggle  _D_: Delete    _p_: previous
  "
  ("f" vimish-fold)
  ("u" vimish-fold-unfold)
  ("r" vimish-fold-refold)
  ("t" vimish-fold-toggle)
  ("d" vimish-fold-delete)
  ("U" vimish-fold-unfold-all)
  ("R" vimish-fold-refold-all)
  ("T" vimish-fold-toggle-all)
  ("D" vimish-fold-delete-all)
  ("n" vimish-fold-next-fold)
  ("p" vimish-fold-previous-fold)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z -" . vimish-fold-toggle)
  ("C-z _" . sk/hydra-vimish-fold/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "-" "C-z -")
(modalka-define-kbd "_" "C-z _")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "-" "sel-based fold toggle"
  "_" "sel-based fold menu")
#+END_SRC

* Writing

** Markdown and Pandoc support

Although I use Org for most of my markup documentation and it has an export function to markdown, these packages give better support. So, why not install them.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode ("\\.markdown\\'" "\\.mkd\\'" "\\.md\\'")
  :config
  (use-package pandoc-mode
    :ensure t
    :mode ("\\.markdown\\'" "\\.mkd\\'" "\\.md\\'")))
#+END_SRC

** \LaTeX support

I use \LaTeX extensively compared to Markdown (although Org is still preferred for shorter reports).

#+BEGIN_SRC emacs-lisp
(use-package tex-site
  :ensure auctex
  :ensure auctex-latexmk
  :ensure latex-preview-pane
  :mode ("\\.tex\\'" "\\.xtx\\'")
  :init
  (setq reftex-default-bibliography '("~/Dropbox/references/references.bib"))
  :config
  (latex-preview-pane-enable))
#+END_SRC

** Pick out passive voice and weasel words

[[https://github.com/bnbeckwith/writegood-mode][Write good]].

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :ensure t
  :diminish writegood-mode
  :config
  (progn
    (add-hook 'text-mode-hook 'writegood-mode)))
#+END_SRC

** Check out the definition of the word

Note that [[https://github.com/abo-abo/define-word][this]] might take a while to get a result.

#+BEGIN_SRC emacs-lisp
(use-package define-word
  :ensure t
  :commands (define-word-at-point
              define-word)
  :bind* (("C-z g ?" . define-word-at-point)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g ?" "C-z g ?")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g ?" "define word")
#+END_SRC

** Distraction free mode

I really liked the way [[https://bywordapp.com][Byword]] presents a writing interface. However, I really cannot edit there because I'm so used to editing on Emacs. So, let's bring that in to Emacs with a [[https://github.com/rnkn/olivetti][a distraction free package]] and a [[https://github.com/larstvei/Focus][package to focus on sections of text]].

#+BEGIN_SRC emacs-lisp
;; Distraction free
(use-package olivetti
  :ensure t
  :diminish olivetti-mode
  :bind* (("C-z g d" . olivetti-mode))
  :config
  (progn
    (olivetti-set-width 100)))
;; Focus on a particular section
(use-package focus
  :ensure t
  :bind* (("C-z g F" . focus-mode)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g d" "C-z g d")
(modalka-define-kbd "g F" "C-z g F")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g d" "distraction free"
  "g F" "focus on sections")
#+END_SRC

* Org

[[http://orgmode.org][Org mode]] is the reason I switched from Vim to Emacs. It is an amazing piece of software that helps in note-taking, organizing, developing this Emacs starter file, writing reports for my grad school. It has single-handedly replaced at least 3 separate applications for me. Without further ado, let's start the Org configuration. I'll try to be as elaborate as possible. Org mode can be used to [[https://www.youtube.com/watch?v=FtieBc3KptU][write books]] and even [[https://www.youtube.com/watch?v=uraPXeLfWcM][learn Mandarin]].

** Basic settings

*** Default directory

Org mode operates from a directory. You need a directory to store all your org files and be default. Typically, you can use Org without setting these but it is useful to set this location to help in capturing and archiving org files effectively. I use Dropbox to sync all my notes with the [[https://play.google.com/store/apps/details?id=com.orgzly][Orgzly]] app on my phone.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org")
#+END_SRC

*** Markup

Org mode has its own [[http://orgmode.org/manual/Markup.html][markup syntax]] but seeing the [[http://orgmode.org/manual/Emphasis-and-monospace.html#Emphasis-and-monospace][emphasis markers]] is distracting. I prefer to hide it.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

*** Minimal outline

If you have read [[http://orgmode.org/org.html#Headlines][how headlines are written]] in org, you can notice that it is by the number of "*" before it. To make it look better, let's indent every heading and remove all the "*" but the last one.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t
      org-hide-leading-stars t)
#+END_SRC

*** Links

Org has the capacity to create links to another headline or document (which is used many times in this document) and the default command for it is bound to =C-c C-o=. Let's make sure pressing enter on the link opens it.

#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

*** Images

The GUI Emacs has the ability to display images. But if the image is pretty large, it displays the whole thing. Let's restrict it from doing that.

#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width '(300))
#+END_SRC

*** Source code

Org mode has the ability to syntax highlight source code blocks that are embedded. Let's explicitly make sure the options we need there.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t)
#+END_SRC

*** Exporting

Org has a [[http://orgmode.org/org.html#Exporting][powerful]] exporting feature. Let's select the various formats to export and also mention how exactly we need it to export to \LaTeX.

#+BEGIN_SRC emacs-lisp
(setq org-export-with-smart-quotes t
      org-latex-to-pdf-process '("pdflatex %f" "biber %b" "pdflatex %f" "pdflatex %f")
      org-export-backens '(beamer html latex md))
#+END_SRC

** Tagging

Org mode has a [[http://orgmode.org/manual/Tags.html][tagging system]] that is very useful to organize the contents and notes. You can select the tags with a single letter (the letter after "?" in the following code).

#+BEGIN_SRC emacs-lisp
(setq org-tag-alist (quote (("article" . ?a) ;; temporary
                            ("books" . ?b)
                            ("courses" . ?c) ;; temporary
                            ("code" . ?C)
                            ("card" . ?d)
                            ("drill" . ?D)
                            ("errand" . ?e)
                            ("films" . ?f)
                            ("gubby" . ?g)
                            ("home" . ?h)
                            ("idea" . ?i)
                            ("job" . ?j)
                            ("ledger" . ?l)
                            ("meeting" . ?m)
                            ("note" . ?n)
                            ("online" . ?o)
                            ("personal" . ?p)
                            ("project" . ?P)
                            ("reference" . ?r) ;; temporary
                            ("story" . ?s)
                            ("technical" . ?t)
                            ("vague" . ?v)
                            ("work" . ?w)
                            ("noexport" . ?x)
                            ("cash" . ?$))))
#+END_SRC

** Task management

Just like tags, Org mode has a built-in way to help manage [[http://orgmode.org/manual/TODO-items.html#TODO-items][tasks]].

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "IN-PROGRESS(i)" "|" "DONE(d!)")
        (sequence "WAITING(w@/!)" "|" "CANCELED(c@)")))
#+END_SRC

** Agenda

The [[http://orgmode.org/manual/Agenda-Views.html][agenda view]] is an amazing way to search your org files for tags, TODOs, keywords, and even view deadlines. There are a couple of things to configure in the agenda view but first let's tell Org which files agenda should look in.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list
                        "~/Dropbox/org/blog.org"
                        "~/Dropbox/org/errands.org"
                        "~/Dropbox/org/phd.org"
                        "~/Dropbox/org/references/articles.org"
                        "~/Dropbox/org/ledger.org"
                        "~/Dropbox/org/notes.org"
                        "~/Dropbox/org/fun.org"))
#+END_SRC

Then, a smaller part of org is the way it shows [[http://orgmode.org/manual/Deadlines-and-scheduling.html][the deadlines]] of all the TODOs and show them in a view that spans a fortnight. It can be set it weekly, monthly or daily too.

#+BEGIN_SRC emacs-lisp
(setq org-deadline-warning-days 7
      org-agenda-span 'fortnight
      org-agenda-skip-scheduled-if-deadline-is-shown t)
#+END_SRC

** Capture

Capture is an [[https://www.youtube.com/watch?v=KdcXu_RdKI0][amazing tool]]. It was the final push to Org and I use it many times per day. First, we have to setup the capture templates. Templates is not that vast and can be easily understood by going through the [[http://orgmode.org/manual/Capture.html#Capture][manual]].

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates '(

        ;; For code snippets
        ("a"               ; key
         "Algo/Code"       ; name
         entry             ; type
         (file+headline "~/Dropbox/org/notes.org" "Code")  ; target
         "* %^{TITLE} %(org-set-tags)  :code:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\#+BEGIN_SRC %^{language}\n%?\n\#END_SRC"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For taking notes on random things
        ("n"               ; key
         "Note"            ; name
         entry             ; type
         (file+headline "~/Dropbox/org/notes.org" "Notes")  ; target
         "* %? %(org-set-tags)  :note:\n:PROPERTIES:\n:Created: %U\n:Linked: %A\n:END:\n%i"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; Ledger is a CLI accounting system
        ("l"               ; key
         "Ledger"          ; name
         entry             ; type
         (file+datetree "~/Dropbox/org/ledger.org" "Ledger")  ; target
         "* %^{expense} %(org-set-tags)  :accounts:\n:PROPERTIES:\n:Created: %U\n:END:\n%i
,#+NAME: %\\1-%t
\#+BEGIN_SRC ledger :noweb yes
%^{Date of expense (yyyy/mm/dd)} %^{'*' if cleared, else blank} %\\1
    %^{Account name}                                $%^{Amount}
    %?
\#+END_SRC
"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For notes or something regarding more work
        ("w"               ; key
         "Work"            ; name
         entry             ; type
         (file+headline "~/Dropbox/org/phd.org" "Work")  ; target
         "* TODO %^{Todo} %(org-set-tags)  :work:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For capturing some things that are worth reading
        ("r"               ; key
         "Reading"         ; name
         entry             ; type
         (file+headline "~/Dropbox/org/fun.org" "Reading")  ; target
         "* %^{Title} %(org-set-tags)\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For capturing minutes of the meeting
        ("m"               ; key
         "Meeting"         ; name
         entry             ; type
         (file+datetree "~/Dropbox/org/phd.org" "Meeting")  ; target
         "* %^{Title} %(org-set-tags)  :meeting:\n:PROPERTIES:\n:Created: %U\n:END:\n%i
Minutes of the meeting:\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; To practice for my driving test
        ("d"               ; key
         "Drill driving"   ; name
         entry             ; type
         (file+headline "~/Dropbox/org/drill.org" "Driving")  ; target
         "* Question  :drill:driving:\n%^{Question}\n** Answer\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For taking notes of math/stats stuff that I keep forgetting
        ("s"              ; key
         "Drill math"     ; name
         entry            ; type
         (file+headline "~/Dropbox/org/drill.org" "Stats/Math")  ; target
         "* Question  :drill:stats:math:\n%^{Question}\n** Answer\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For capturing some physics concepts that I need to remember
        ("p"              ; key
         "Drill physics"  ; name
         entry            ; type
         (file+headline "~/Dropbox/org/drill.org" "Physics")  ; target
         "* Question  :drill:physics:\n%^{Question}\n** Answer\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; For capturing details of a job application/details
        ("j"                      ; key
         "Jobs"                   ; name
         table-line               ; type
         (file+headline "~/Dropbox/org/notes.org" "Jobs")  ; target
         "| %u | %^{Company} | [[%^{job link}][%^{position}]] | %^{referrals?} | %^{Experience?} | %^t | %^{Status} | %^{Follow up} | %^{Result} |"  ; template
         :prepend t               ; properties
         ;; :table-line-pos "II-3"   ; properties
         :empty-lines 1           ; properties
         :created t               ; properties
         :kill-buffer t)          ; properties

        ;; To capture movies that I plan to see
        ("f"              ; key
         "films"          ; name
         entry            ; type
         (file+headline "~/Dropbox/org/fun.org" "Movies")  ; target
         "* %^{Movie} %(org-set-tags)  :film:\n:PROPERTIES:\n:Created: %U\n:END:\n%i
Netflix?: %^{netflix? Yes/No}\nGenre: %^{genre}\nDescription:\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; To capture ideas for my blog
        ("b"               ; key
         "Blog"            ; name
         entry             ; type
         (file+headline "~/Dropbox/org/blog.org" "Blog")  ; target
         "* %^{Title} %(org-set-tags)  :blog:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; To capture tons of errands
        ("e"               ; key
         "Errands"         ; name
         entry             ; type
         (file+headline "~/Dropbox/org/errands.org" "Errands")  ; target
         "* TODO %^{Todo} %(org-set-tags)  :errands:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t)   ; properties

        ;; To capture things regarding my course
        ("c"               ; key
         "Courses"         ; name
         entry             ; type
         (file+headline "~/Dropbox/org/phd.org" "Courses")  ; target
         "* %^{Course} %(org-set-tags)  :courses:\n:PROPERTIES:\n:Created: %U\n:END:\n%i\n%?"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t))) ; properties
#+END_SRC

Then, we have to choose where to [[http://orgmode.org/manual/Capture-_002d-Refile-_002d-Archive.html][refile and archive]] too.

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))
(setq org-refile-use-outline-path t
      org-outline-path-complete-in-steps nil)
#+END_SRC

** Setup org

Finally, we make sure we bind some keys and add some [[http://orgmode.org/manual/Easy-Templates.html][easy template expansion]].

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org
  :bind* (("C-z o a" . org-agenda)
          ("C-z o c" . org-capture)
          ("C-z o i" . org-insert-link)
          ("C-z o s" . org-store-link)
          ("C-z o S" . org-list-make-subtree)
          ("C-z o A" . org-archive-subtree)
          ("C-z o g" . org-goto)
          ("C-z o l" . org-toggle-latex-fragment)
          ("C-z o L" . org-toggle-link-display)
          ("C-z o I" . org-toggle-inline-images)
          ("C-z o k" . org-cut-subtree)
          ("C-z o V" . org-reveal)
          ("C-z o R" . org-refile)
          ("C-z o y" . org-copy-subtree)
          ("C-z o h" . org-toggle-heading)
          ("C-z o H" . org-insert-heading-respect-content)
          ("C-z o e" . org-export-dispatch)
          ("C-z o u" . org-update-dblock)
          ("C-z o U" . org-update-all-dblocks)
          ("C-z o O" . org-footnote)
          ("C-z o ]" . org-narrow-to-subtree)
          ("C-z o [" . widen)
          ("C-z o N" . org-note)
          ("C-z o E" . org-set-effort)
          ("C-z o B" . org-table-blank-field)
          ("C-z o <" . org-date-from-calendar)
          ("C-z o >" . org-goto-calendar)
          ("C-z o d" . org-todo)
          ("C-z o t" . org-set-tags-command)
          ("C-z o w" . org-edit-special)
          ("C-z o q" . org-edit-src-exit)
          ("C-z o z" . clone-indirect-buffer-other-window)
          ("C-z i s" . org-mark-subtree))
  :config
  ;; More of those nice template expansion
  (add-to-list 'org-structure-template-alist '("A" "#+DATE: ?"))
  (add-to-list 'org-structure-template-alist '("C" "#+BEGIN_CENTER\n?\n#+END_CENTER\n"))
  (add-to-list 'org-structure-template-alist '("D" "#+BEGIN_FSTREE ?"))
  (add-to-list 'org-structure-template-alist '("E" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE\n"))
  (add-to-list 'org-structure-template-alist '("H" "#+LATEX_HEADER: ?"))
  (add-to-list 'org-structure-template-alist '("I" ":INTERLEAVE_PDF: ?"))
  (add-to-list 'org-structure-template-alist '("L" "#+BEGIN_LaTeX\n?\n#+END_LaTeX"))
  (add-to-list 'org-structure-template-alist '("N" "#+BEGIN_NOTES\n?\n#+END_NOTES"))
  (add-to-list 'org-structure-template-alist '("T" ":DRILL_CARD_TYPE: twosided"))
  (add-to-list 'org-structure-template-alist '("V" "#+BEGIN_VERSE\n?\n#+END_VERSE"))
  (add-to-list 'org-structure-template-alist '("a" "#+AUTHOR: ?"))
  (add-to-list 'org-structure-template-alist '("b" ":reveal_background_trans: ?"))
  (add-to-list 'org-structure-template-alist '("c" "#+CAPTION: ?"))
  (add-to-list 'org-structure-template-alist '("d" "#+OPTIONS: toc:nil num:nil tags:nil todo:nil p:nil pri:nil stat:nil c:nil d:nil\n#+LATEX_HEADER: \\usepackage[margin=2cm]{geometry}\n#+EXCLUDE_TAGS: noexport\n"))
  (add-to-list 'org-structure-template-alist '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("f" "#+ATTR_REVEAL: :frag ?"))
  (add-to-list 'org-structure-template-alist '("h" "#+BEGIN_HTML\n?\n#+END_HTML\n"))
  (add-to-list 'org-structure-template-alist '("i" "#+INTERLEAVE_PDF: ?"))
  (add-to-list 'org-structure-template-alist '("l" "#+LABEL: ?"))
  (add-to-list 'org-structure-template-alist '("m" "#+BEGIN_SRC matlab\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("n" "#+NAME: ?"))
  (add-to-list 'org-structure-template-alist '("o" "#+OPTIONS: ?"))
  (add-to-list 'org-structure-template-alist '("p" "#+BEGIN_SRC python\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE"))
  (add-to-list 'org-structure-template-alist '("r" ":PROPERTIES:\n?\n:END:"))
  (add-to-list 'org-structure-template-alist '("s" "#+BEGIN_SRC ?\n#+END_SRC\n"))
  (add-to-list 'org-structure-template-alist '("t" "#+TITLE: ?"))
  (add-to-list 'org-structure-template-alist '("v" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM")))
#+END_SRC

*** Which key binding explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
    "C-z o" "org mode prefix")
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o a" "C-z o a")
(modalka-define-kbd "o c" "C-z o c")
(modalka-define-kbd "o i" "C-z o i")
(modalka-define-kbd "o s" "C-z o s")
(modalka-define-kbd "o S" "C-z o S")
(modalka-define-kbd "o A" "C-z o A")
(modalka-define-kbd "o g" "C-z o g")
(modalka-define-kbd "o l" "C-z o l")
(modalka-define-kbd "o L" "C-z o L")
(modalka-define-kbd "o I" "C-z o I")
(modalka-define-kbd "o k" "C-z o k")
(modalka-define-kbd "o V" "C-z o V")
(modalka-define-kbd "o R" "C-z o R")
(modalka-define-kbd "o y" "C-z o y")
(modalka-define-kbd "o h" "C-z o h")
(modalka-define-kbd "o H" "C-z o H")
(modalka-define-kbd "o e" "C-z o e")
(modalka-define-kbd "o u" "C-z o u")
(modalka-define-kbd "o U" "C-z o U")
(modalka-define-kbd "o O" "C-z o O")
(modalka-define-kbd "o ]" "C-z o ]")
(modalka-define-kbd "o [" "C-z o [")
(modalka-define-kbd "o N" "C-z o N")
(modalka-define-kbd "o E" "C-z o E")
(modalka-define-kbd "o B" "C-z o B")
(modalka-define-kbd "o <" "C-z o <")
(modalka-define-kbd "o >" "C-z o >")
(modalka-define-kbd "o d" "C-z o d")
(modalka-define-kbd "o t" "C-z o t")
(modalka-define-kbd "o z" "C-z o z")
(modalka-define-kbd "o w" "C-z o w")
(modalka-define-kbd "o q" "C-z o q")
(modalka-define-kbd "i s" "C-z i s")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
 "o" "org prefix"
  "o a" "org agenda"
  "o c" "org capture"
  "o i" "org insert link"
  "o s" "org store link"
  "o S" "org subtree from list"
  "o A" "org archive subtree"
  "o g" "org goto"
  "o l" "org latex preview"
  "o L" "org toggle link display"
  "o I" "org image preview"
  "o k" "org kill subtree"
  "o V" "org reveal"
  "o R" "org refile"
  "o y" "org copy subtree"
  "o h" "org toggle heading"
  "o H" "org insert heading"
  "o e" "org export"
  "o u" "org update current"
  "o U" "org update all"
  "o O" "org footnote"
  "o ]" "org narrow subtree"
  "o [" "org widen"
  "o N" "org note"
  "o F" "org attach"
  "o E" "org set effort"
  "o B" "org table blank field"
  "o <" "org select from cal"
  "o >" "org goto cal"
  "o t" "org tag"
  "o d" "org todo"
  "o z" "split and clone"
  "o w" "org special edit"
  "o q" "org special edit quit"
  "i s" "mark org subtree")
#+END_SRC

** Org contributed packages

[[http://orgmode.org/worg/org-contrib/][Org plus contrib]] is a package comprised of contributed packages to make Org a bit better. Although there are lot of packages in it, the one I want to load it for is [[http://orgmode.org/worg/org-contrib/org-drill.html][Org drill]] to help me repeatedly memorize stuff.

#+BEGIN_SRC emacs-lisp
(use-package org-drill
  :defer t
  :commands (org-drill
             org-drill-tree
             org-drill-directory)
  :init
  (setq org-drill-maximum-items-per-session 30)
  (setq org-drill-maximum-duration 20)   ; 30 minutes
  (setq org-drill-use-visible-cloze-face-p t)
  (setq org-drill-add-random-noise-to-intervals-p t)
  (setq org-drill-hint-separator "||")
  (setq org-drill-left-cloze-delimiter "<[")
  (setq org-drill-right-cloze-delimiter "]>")
  (setq org-drill-learn-fraction 0.25)
  :config
  (progn
    (add-to-list 'org-modules 'org-drill)))
#+END_SRC

** Org babel

[[http://orgmode.org/worg/org-contrib/babel/][Org babel]] is also another facet of Org I use so much. In fact, writing this entire file as a configuration is possible only because of babel.

#+BEGIN_SRC emacs-lisp
(use-package babel
  :ensure t
  :init
  (setq org-confirm-babel-evaluate nil)
  :defer t
  :config
  (use-package ob-ipython
    :ensure t
    :defer t))
#+END_SRC

** Deft

[[http://jblevins.org/projects/deft/][Deft]] is inspired by [[http://notational.net][Notational velocity]] to quickly filter notes. It is a generic package that works with many files but I use it to quickly filter text files with any extension. I use it for Org mode.

#+BEGIN_SRC emacs-lisp
(use-package deft
  :ensure t
  :commands (deft)
  :init
  (setq deft-extensions '("org")
        deft-recursive nil
        deft-use-filename-as-title t))
#+END_SRC

If you notice, there is no directory specified. This is because I usually want deft to search different directories when invoked differently. So, let's add a wrapper function [[http://pragmaticemacs.com/emacs/deft-as-a-file-search-tool/][similar to the post in pragmatic emacs blog]]. The function below wraps around deft and sets the directory when called with an argument.

#+BEGIN_SRC emacs-lisp
(defun sk/deft (dir)
  "Run deft in directory DIR"
  (setq deft-directory dir)
  (switch-to-buffer "*Deft*")
  (kill-this-buffer)
  (deft))
#+END_SRC

Let's define a couple of functions that use this wrapper function.

#+BEGIN_SRC emacs-lisp
(defun sk/deft-org ()
  "Uses the sk/deft function to search in the default org directory"
  (interactive)
  (sk/deft "~/Dropbox/org"))
(defun sk/deft-blog ()
  "Uses the sk/deft function to search in the blog posts directory"
  (interactive)
  (sk/deft "~/Dropbox/org/blogposts/posts"))
#+END_SRC

*** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o f" . sk/deft-org)
  ("C-z o F" . sk/deft-blog))
#+END_SRC

**** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o f" "C-z o f")
(modalka-define-kbd "o F" "C-z o F")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o f" "filter org files"
  "o F" "filter blog posts")
#+END_SRC

** Interleave

Interleaved notes are a thing of the past but you can [[https://github.com/rudolfochrist/interleave][get that on Org now]].

#+BEGIN_SRC emacs-lisp
(use-package interleave
  :ensure t
  :bind* (("C-z o n" . interleave))
  :commands (interleave interleave-pdf-mode))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o n" "C-z o n")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o n" "org notes")
#+END_SRC

** Org cdlatex

Of course, you can [[https://www.gnu.org/software/emacs/manual/html_node/org/CDLaTeX-mode.html][write \LaTeX in Org]].

#+BEGIN_SRC emacs-lisp
(use-package cdlatex
  :ensure t
  :diminish org-cdlatex-mode
  :config
  (progn
    (add-hook 'org-mode-hook 'org-cdlatex-mode)))
#+END_SRC

I also want to diminish it so that it doesn't show up on the modeline.

#+BEGIN_SRC emacs-lisp
(defun sk/diminish-org-cdlatex ()
  (interactive)
  (diminish 'org-cdlatex-mode ""))
(add-hook 'org-cdlatex-mode-hook 'sk/diminish-org-cdlatex)
#+END_SRC

** Org extra exports

Org already has a pretty good [[*Exporting][exporting system]] but we can make it better. It can export to a [[https://github.com/yjwen/org-reveal][a reveal.js presentation]] or a HTML page with [[https://github.com/marsmining/ox-twbs][bootstrap]].

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :ensure t
  :defer t
  :init
  (setq org-reveal-title-slide-template
        "<h1>%t</h1>\n<h3>%a</h3>")
  (setq org-reveal-root "file:///Users/sriramkswamy/Documents/workspace/github/reveal.js"))
(use-package ox-twbs
  :ensure t
  :defer t)
#+END_SRC

** Org download

[[https://github.com/abo-abo/org-download][You can drag and drop images in to an org file]].

#+BEGIN_SRC emacs-lisp
(use-package org-download
  :ensure t
  :defer 2)
#+END_SRC

** Org bullets

We can make Org mode a little more pretty by having [[https://github.com/sabof/org-bullets][utf-8 bullets]].

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (progn
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))
#+END_SRC

** Org reference

[[https://github.com/jkitchin/org-ref][Org ref]] is an amazing package. The best introduction to this package is a [[https://www.youtube.com/watch?v=2t925KRBbFc][video by the author himself]].

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t
  :defer t
  :init
  (setq org-ref-completion-library 'org-ref-ivy-bibtex)
  (setq org-ref-notes-directory "~/Dropbox/org/references/notes"
        org-ref-bibliography-notes "~/Dropbox/org/references/articles.org"
        org-ref-default-bibliography '("~/Dropbox/org/references/multiphysics.bib" "~/Dropbox/org/references/chanceconstraints.bib")
        org-ref-pdf-directory "~/Dropbox/org/references/pdfs/")
  :config
  (use-package helm
    :ensure t
    :config
    (use-package helm-bibtex
      :ensure t)))
#+END_SRC

** Functions

Org mode and packages take a while to load. This command, when invoked, loads a bunch of extra stuff. So, I use it whenever I'm doing serious work in Org mode. Note that the first time you invoke this function, it will install the [[http://orgmode.org/elpa.html][org-plus-contrib]] package if it is not installed already.

#+BEGIN_SRC emacs-lisp
(defun sk/org-custom-load ()
  (interactive)
  (require 'org)
  ;; Some exports
  (require 'ox-reveal)
  (require 'ox-twbs)
  ;; References and citation
  (require 'org-ref)
  (require 'org-ref-latex)
  (require 'org-ref-pdf)
  (require 'org-ref-url-utils)
  ;; Flash cards
  (require 'org-drill)
  ;; Babel load
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     ;; (dot . t)
     ;; (ditaa . t)
     (latex . t)
     ;; (gnuplot . t)
     (sh . t)
     ;; (C . t)
     (ledger . t)
     ;; (R . t)
     ;; (octave . t)
     (matlab . t)
     (python . t))))
;; Add obvious org mode hooks
(add-hook 'org-mode-hook 'visual-line-mode)
(add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

** Hydras

There is so much functionality packed into org and those modifier keys are hard to press. Let's leverage [[*Hydras][Hydras]].

*** Organize trees

This is to rearrange sub trees, reorder them, promote, demote and cycle through TODOs.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-organize (:color red
                                 :hint nil)
  "
 ^Move^                                       ^Item^
^^^^^^^^^^^^^--------------------------------------------------------------------
 ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   ^ ^ _p_ ^ ^  ^ ^ _P_ ^ ^   _<_: promote  _u_: up     _q_: quit
 _h_ ^+^ _l_   _H_ ^+^ _L_   _b_ ^+^ _f_  _B_ ^+^ _F_   _>_: demote   _d_: down
 ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   ^ ^ _n_ ^ ^  ^ ^ _N_ ^ ^
"
  ("h" org-metaleft)
  ("l" org-metaright)
  ("j" org-metadown)
  ("k" org-metaup)
  ("H" org-shiftleft)
  ("L" org-shiftright)
  ("J" org-shiftdown)
  ("K" org-shiftup)
  ("b" org-shiftmetaleft)
  ("f" org-shiftmetaright)
  ("n" org-shiftmetadown)
  ("p" org-shiftmetaup)
  ("B" org-shiftcontrolleft)
  ("F" org-shiftcontrolright)
  ("P" org-shiftcontroldown)
  ("N" org-shiftcontrolup)
  ("<" org-promote)
  (">" org-demote)
  ("d" org-move-item-down)
  ("u" org-move-item-up)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o o" . sk/hydra-org-organize/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o o" "C-z o o")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o o" "organize trees")
#+END_SRC

*** Hydra for task management

As mentioned [[*Task management][before]], Org is amazing for TODO lists and has the ability to schedule deadlines too.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-todo (:color red
                             :hint nil)
  "
 _d_: deadline    _o_: over    _s_: schedule   _c_: check   _q_: quit
"
  ("d" org-deadline :color blue)
  ("o" org-deadline-close :color blue)
  ("s" org-schedule :color blue)
  ("c" org-check-deadlines)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o D" . sk/hydra-org-todo/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o D" "C-z o D")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o D" "deadline menu")
#+END_SRC

*** Check boxes

[[http://orgmode.org/manual/Checkboxes.html][Org supports checkboxes]] and my configuration should too.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-checkbox (:color red
                                 :hint nil)
  "
 _t_: toggle   _s_: stats    _r_: reset    _c_: count    _q_: quit
"
  ("t" org-toggle-checkbox)
  ("c" org-update-checkbox-count-maybe)
  ("r" org-reset-checkbox-state-subtree)
  ("s" org-update-statistics-cookies)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o b" . sk/hydra-org-checkbox/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o b" "C-z o b")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o b" "check boxes")
#+END_SRC

*** Properties

[[http://orgmode.org/manual/Properties-and-Columns.html][Org properties]] are really good places to have meta data. Although I personally don't create many properties manually, it is useful to have this functionality around.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-property (:color red
                                 :hint nil)
  "
 _i_: insert  _p_: property   _s_: set    _d_: delete    _t_: toggle    _q_: quit
"
  ("i" org-insert-drawer)
  ("p" org-insert-property-drawer)
  ("s" org-set-property)
  ("d" org-delete-property)
  ("t" org-toggle-ordered-property)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o P" . sk/hydra-org-property/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o P" "C-z o P")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o P" "add properties")
#+END_SRC

*** Clocking functionality

[[http://orgmode.org/manual/Clocking-work-time.html][Of course, Org mode has clocking functionality]].

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-clock (:color red
                              :hint nil)
  "
 ^Clock^                     ^Timer^     ^Stamp^
^^^^^^^^^^-------------------------------------------------
 _i_: in       _z_: resolve    _b_: begin  _t_: stamp       _q_: quit
 _o_: out      _l_: last       _e_: end    _u_: inactive
 _r_: report   _c_: cancel     _m_: timer
 _d_: display  _g_: goto       _s_: set
"
  ("i" org-clock-in)
  ("o" org-clock-out)
  ("r" org-clock-report)
  ("z" org-resolve-clocks)
  ("c" org-clock-cancel)
  ("d" org-clock-display)
  ("l" org-clock-in-last)
  ("g" org-clock-goto)
  ("m" org-timer)
  ("s" org-timer-set-timer)
  ("b" org-timer-start)
  ("e" org-timer-stop)
  ("t" org-time-stamp)
  ("u" org-time-stamp-inactive)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o C" . sk/hydra-org-clock/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o C" "C-z o C")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o C" "clocking")
#+END_SRC

*** Table manipulation

Org mode can create [[http://orgmode.org/manual/Tables.html][tables]] with [[http://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html][spreadsheet capabilities]].

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-tables (:color red
                               :hint nil)
  "
 ^Field^   ^Shift^   ^Insert^      ^Delete^         ^Field^     ^Table^      ^Formula^
^^^^^^^^^^^^------------------------------------------------------------------------------
 ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   _r_: row      _dr_: del row    _e_: edit   _a_: align   _+_: sum    _q_: quit
 _h_ ^+^ _l_   _H_ ^+^ _L_   _c_: column   _dc_: del col    _b_: blank  _|_: create  _=_: eval
 ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   _-_: hline                   _i_: info             _f_: edit
"
  ("a" org-table-align)
  ("l" org-table-next-field)
  ("h" org-table-previous-field)
  ("j" org-table-end-of-field)
  ("k" org-table-beginning-of-field)
  ("r" org-table-insert-row)
  ("c" org-table-insert-column)
  ("-" org-table-insert-hline)
  ("J" org-table-move-row-down)
  ("K" org-table-move-row-up)
  ("H" org-table-move-column-left)
  ("L" org-table-move-column-right)
  ("dr" org-table-kill-row)
  ("dc" org-table-delete-column)
  ("b" org-table-blank-field)
  ("e" org-table-edit-field)
  ("i" org-table-field-info)
  ("+" org-table-sum)
  ("=" org-table-eval-formula)
  ("f" org-table-edit-formulas)
  ("|" org-table-create-or-convert-from-region)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o m" . sk/hydra-org-tables/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o m" "C-z o m")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o m" "manipulate table")
#+END_SRC

*** Jump

This is a massively useful hydra to move around in an org file

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-jump (:color pink
                             :hint nil)
  "
 ^Outline^          ^Item^   ^Table^   ^Block^   ^Link^
 ^^^^^^^^^^^-------------------------------------------------------------------------------
 ^ ^ _k_ ^ ^   ^ ^ _K_ ^ ^   ^ ^ _u_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _p_ ^ ^   ^ ^ _P_ ^ ^    _q_ quit
 _h_ ^+^ _l_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^   _b_ ^+^ _f_   ^ ^ ^+^ ^ ^   ^ ^ ^+^ ^ ^
 ^ ^ _j_ ^ ^   ^ ^ _J_ ^ ^   ^ ^ _d_ ^ ^   ^ ^ ^ ^ ^ ^   ^ ^ _n_ ^ ^   ^ ^ _N_ ^ ^
"
  ("j" outline-next-visible-heading)
  ("k" outline-previous-visible-heading)
  ("l" org-down-element)
  ("h" org-up-element)
  ("J" org-forward-heading-same-level)
  ("K" org-backward-heading-same-level)
  ("u" org-next-item)
  ("d" org-previous-item)
  ("f" org-table-next-field)
  ("b" org-table-previous-field)
  ("n" org-next-block)
  ("p" org-previous-block)
  ("N" org-next-link)
  ("P" org-previous-link)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o j" . sk/hydra-org-jump/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o j" "C-z o j")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o j" "jump around")
#+END_SRC

*** Agenda view

The agenda menu already has a built-in agenda view but I always forget the keys. So, I need some reminding

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-agenda-view (:color red
                                    :hint nil)
  "
 _d_: day        _g_: time grid    _a_: arch-trees    _L_: log closed clock
 _w_: week       _i_: inactive     _A_: arch-files    _c_: log clock check
 _t_: fortnight  _f_: follow       _r_: report        _l_: log mode toggle
 _m_: month      _e_: entry        _D_: diary         _q_: quit
 _y_: year       _!_: deadlines    _R_: reset
"
  ("R" org-agenda-reset-view)
  ("d" org-agenda-day-view)
  ("w" org-agenda-week-view)
  ("t" org-agenda-fortnight-view)
  ("m" org-agenda-month-view)
  ("y" org-agenda-year-view)
  ("l" org-agenda-log-mode)
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode)
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode)
  ("e" org-agenda-entry-text-mode)
  ("g" org-agenda-toggle-time-grid)
  ("D" org-agenda-toggle-diary)
  ("!" org-agenda-toggle-deadlines)
  ("i"
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o v" . sk/hydra-org-agenda-view/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o v" "C-z o v")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o v" "view agenda")
#+END_SRC

*** Org drill

As [[*Org contributed packages][previously mentioned]], I use the drill package from Org drill and I want to invoke it via different commands at different times.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-drill (:color blue
                              :hint nil)
  "
 _f_: file    _h_: heading    _d_: directory   _q_: quit
"
  ("f" org-drill)
  ("h" org-drill-tree)
  ("d" org-drill-directory)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o p" . sk/hydra-org-drill/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o p" "C-z o p")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o p" "practice")
#+END_SRC

*** Template expansion

Org has this useful feature of [[*Setup org][template expansion]] but I have so many templates that I forget their combinations. This first function is a wrapper to call those template expansions.

#+BEGIN_SRC emacs-lisp
(defun hot-expand (str)
  "Expand org template."
  (insert str)
  (org-try-structure-completion))
#+END_SRC

Then, we have the actual hydra.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-template (:color blue
                                 :hint nil)
  "
 ^One liners^                      ^Blocks^                                        ^Properties^
------------------------------------------------------------------------------------------------------------------------------------
 _a_: author        _i_: interleave  _C_: center      _m_: matlab src    _V_: verse      _r_: properties        _<_: insert '<'
 _A_: date          _l_: label       _D_: dir tree    _p_: python src    _d_: defaults   _I_: interleave        _q_: quit
 _c_: caption       _n_: name        _e_: elisp src   _Q_: quote         _L_: latex      _T_: drill two-sided
 _f_: reveal frag   _o_: options     _E_: example     _s_: src                         _b_: reveal trans
 _H_: latex header  _t_: title       _h_: html        _v_: verbatim
 "
  ("a" (hot-expand "<a"))
  ("A" (hot-expand "<A"))
  ("c" (hot-expand "<c"))
  ("f" (hot-expand "<f"))
  ("H" (hot-expand "<H"))
  ("i" (hot-expand "<i"))
  ("I" (hot-expand "<I"))
  ("l" (hot-expand "<l"))
  ("n" (hot-expand "<n"))
  ("o" (hot-expand "<o"))
  ("t" (hot-expand "<t"))
  ("C" (hot-expand "<C"))
  ("D" (hot-expand "<D"))
  ("e" (hot-expand "<e"))
  ("E" (hot-expand "<E"))
  ("h" (hot-expand "<h"))
  ("m" (hot-expand "<m"))
  ("p" (hot-expand "<p"))
  ("Q" (hot-expand "<q"))
  ("s" (hot-expand "<s"))
  ("v" (hot-expand "<v"))
  ("V" (hot-expand "<V"))
  ("d" (hot-expand "<d"))
  ("L" (hot-expand "<L"))
  ("r" (hot-expand "<r"))
  ("I" (hot-expand "<I"))
  ("T" (hot-expand "<T"))
  ("b" (hot-expand "<b"))
  ("<" self-insert-command)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

This key binding is a little different. The following function invokes the hydra if the "<" character (which is the key for template expansion) is pressed while in a new line else just inserts "<".

#+BEGIN_SRC emacs-lisp
(defun sk/org-template-hook ()
  (define-key org-mode-map "<"
    (lambda () (interactive)
      (if (looking-back "^")
          (sk/hydra-org-template/body)
        (self-insert-command 1)))))
(add-hook 'org-mode-hook 'sk/org-template-hook)
#+END_SRC

*** Org ref

These are hydras for all the functionality of [[*Org reference][org ref]]. Although the first 3 ones have similar versions defined in the actual package, there were a few inconsistencies when I first installed it. So, I made these hydras. I'm keeping them. The first 3 pieces of code are hydras that have alternatives in the package. The last one is the one that will be invoked.

#+BEGIN_SRC emacs-lisp
(defhydra sk/org-ref-bibtex-file (:color blue
                                  :hint nil)
  "
_v_: validate     _s_: sort     _r_: reformat     _c_: count     _p_: PDF      _q_: quit
  "
  ("v" bibtex-validate)
  ("s" bibtex-sort-buffer)
  ("r" bibtex-reformat)
  ("c" bibtex-count-entries)
  ("p" org-ref-build-full-bibliography)
  ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra sk/org-ref-bibtex-new-entry (:color blue
                                       :hint nil)
  "
_a_: article                 _b_: book      _p_: in proceedings   _M_: Manual      _u_: unpublished
_c_: article in collection   _i_: in book   _P_: proceedings      _t_: PhD thesis  _q_: quit
_r_: report                  _l_: booklet   _m_: Misc             _T_: MS thesis
  "
  ("a" bibtex-Article)
  ("c" bibtex-InCollection)
  ("r" bibtex-TechReport)
  ("b" bibtex-Book)
  ("i" bibtex-InBook)
  ("l" bibtex-Booklet)
  ("p" bibtex-InProceedings)
  ("P" bibtex-Proceedings)
  ("m" bibtex-Misc)
  ("M" bibtex-Manual)
  ("t" bibtex-PhdThesis)
  ("T" bibtex-MastersThesis)
  ("u" bibtex-Unpublished)
  ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra sk/org-ref-bibtex-hydra (:color blue
                                   :hint nil)
  "
_p_: Open pdf     _y_: Copy key               _n_: New entry     _w_: WOS
_b_: Open url     _f_: Copy formatted entry   _o_: Copy entry    _c_: WOS citing
_r_: Refile entry _k_: Add keywords           _d_: delete entry  _a_: WOS related
_e_: Email entry  _K_: Edit keywords          _L_: clean entry   _P_: Pubmed
_U_: Update entry _N_: Open notes             _R_: Crossref      _g_: Google Scholar
_s_: Sort entry   _A_: Remove nonascii        _C_: Cite entry    _q_: quit
_u_: Update field _F_: file funcs
"
  ("p" org-ref-open-bibtex-pdf)
  ("b" org-ref-open-in-browser)
  ("r" (lambda () (interactive)
         (bibtex-beginning-of-entry)
         (bibtex-kill-entry)
         (find-file (ido-completing-read
                     "Bibtex file: "
                     (f-entries "." (lambda (f) (f-ext? f "bib")))))
         (goto-char (point-max))
         (bibtex-yank)
         (save-buffer)
         (kill-buffer)))
  ("e" org-ref-email-bibtex-entry)
  ("U" (doi-utils-update-bibtex-entry-from-doi (org-ref-bibtex-entry-doi)))
  ("s" org-ref-sort-bibtex-entry)
  ("u" doi-utils-update-field)
  ("y" (kill-new  (bibtex-autokey-get-field "=key=")))
  ("f" bibtex-copy-summary-as-kill)
  ("k" helm-tag-bibtex-entry)
  ("K" (lambda ()
         (interactive)
         (org-ref-set-bibtex-keywords
          (read-string "Keywords: "
                       (bibtex-autokey-get-field "keywords"))
          t)))
  ("N" org-ref-open-bibtex-notes)
  ("A" org-ref-replace-nonascii)
  ("F" sk/org-ref-bibtex-file/body)
  ("n" sk/org-ref-bibtex-new-entry/body)
  ("o" bibtex-copy-entry-as-kill)
  ("d" bibtex-kill-entry)
  ("L" org-ref-clean-bibtex-entry)
  ("R" org-ref-bibtex-crossref)
  ("w" org-ref-bibtex-wos)
  ("c" org-ref-bibtex-wos-citing)
  ("a" org-ref-bibtex-wos-related)
  ("P" org-ref-bibtex-pubmed)
  ("g" org-ref-bibtex-google-scholar)
  ("C" sk/org-ref-cite-hydra/body)
  ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-org-ref (:color blue
                            :hint nil)
  "
 _e_: bib new entry     _r_: ref link     _b_: bib file options
 _t_: crossref entry    _l_: label link   _f_: file format
 _d_: doi entry         _c_: cite link    _q_: quit
  "
  ("e" sk/org-ref-bibtex-new-entry/body)
  ("t" crossref-add-bibtex-entry)
  ("d" doi-add-bibtex-entry)
  ("b" sk/org-ref-bibtex-hydra/body)
  ("r" org-ref-ivy-insert-ref-link)
  ("l" org-ref-ivy-insert-label-link)
  ("c" org-ref-ivy-insert-cite-link)
  ("f" sk/org-ref-bibtex-file/body)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z o r" . sk/hydra-org-org-ref/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "o r" "C-z o r")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "o r" "org ref")
#+END_SRC

* Version control

** Magit

[[https://magit.vc][The best interface to Git ever]]. Enough said.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind* (("C-z SPC e" . magit-status)
          ("C-z g b" . magit-blame)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC e" "C-z SPC e")
(modalka-define-kbd "g b" "C-z g b")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC e" "explore git"
  "g b" "git blame")
#+END_SRC

** Highlight diffs

[[https://github.com/dgutov/diff-hl][Highlight git diffs on the fly]].

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t
  :commands (global-diff-hl-mode
             diff-hl-mode
             diff-hl-next-hunk
             diff-hl-previous-hunk
             diff-hl-mark-hunk
             diff-hl-diff-goto-hunk
             diff-hl-revert-hunk)
  :bind* (("C-z ] h" . diff-hl-next-hunk)
          ("C-z [ h" . diff-hl-previous-hunk)
          ("C-z i h" . diff-hl-mark-hunk)
          ("C-z g h" . diff-hl-diff-goto-hunk)
          ("C-z g H" . diff-hl-revert-hunk))
  :config
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  (diff-hl-margin-mode)
  (diff-hl-dired-mode))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "] h" "C-z ] h")
(modalka-define-kbd "[ h" "C-z [ h")
(modalka-define-kbd "g h" "C-z g h")
(modalka-define-kbd "g H" "C-z g H")
(modalka-define-kbd "i h" "C-z i h")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "] h" "next git hunk"
  "[ h" "previous git hunk"
  "g h" "goto git hunk"
  "g H" "revert git hunk"
  "i h" "select git hunk")
#+END_SRC

** Git time machine

The ability to move to past versions of the current file, [[https://github.com/pidu/git-timemachine][like a time machine]].

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :commands (git-timemachine-toggle
             git-timemachine-switch-branch)
  :bind* (("C-z g l" . git-timemachine-toggle)
          ("C-z g L" . git-timemachine-switch-branch)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g l" "C-z g l")
(modalka-define-kbd "g L" "C-z g L")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g l" "git time machine"
  "g L" "time machine switch branch")
#+END_SRC

** Gists

[[https://help.github.com/articles/about-gists/][Gists]] is a nice feature of GitHub to share code easily. [[https://github.com/mhayashi1120/yagist.el][This package]] makes it easy to post code into a Gist.

#+BEGIN_SRC emacs-lisp
(use-package yagist
  :ensure t
  :commands (yagist-region-or-buffer
             yagist-region-or-buffer-private)
  :bind* (("C-z g p" . yagist-region-or-buffer)
          ("C-z g P" . yagist-region-or-buffer-private))
  :init
  (setq yagist-encrypt-risky-config t))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g p" "C-z g p")
(modalka-define-kbd "g P" "C-z g P")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g p" "gist public"
  "g P" "gist private")
#+END_SRC

* Programming

** Editorconfig

[[http://editorconfig.org][Editorconfig]] is a small utility that is helpful in keeping the code clean as it takes care of the necessary indentation and can be used across editors.

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :demand t
  :config
  (editorconfig-mode 1))
#+END_SRC

** YAML mode

YAML is a plain text file format used by many places to specify meta data. This provides some syntax highlighting for that.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :mode "\\.yml$")
#+END_SRC

** Start services

I often need to start some service/program in the background and instead of dropping down to the terminal every time, [[https://github.com/rejeep/prodigy.el][prodigy]] provides a better alternative to define a service, start and stop from within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package prodigy
  :ensure t
  :commands (prodigy)
  :bind* (("C-z c b" . prodigy))
  :init
  (prodigy-define-tag
    :name 'blog
    :ready-message "Serving blog. Ctrl-C to shutdown server")
  (prodigy-define-service
    :name "Nikola build"
    :command "nikola"
    :args '("build")
    :cwd "/Users/sriramkswamy/Dropbox/org/blogposts"
    :tags '(blog)
    :kill-signal 'sigkill)
  (prodigy-define-service
    :name "Nikola serve"
    :command "nikola"
    :args '("serve" "--browser")
    :cwd "/Users/sriramkswamy/Dropbox/org/blogposts"
    :tags '(blog)
    :kill-signal 'sigkill
    :kill-process-buffer-on-stop t)
  (prodigy-define-service
    :name "Nikola deploy"
    :command "nikola"
    :args '("github_deploy")
    :cwd "/Users/sriramkswamy/Dropbox/org/blogposts"
    :tags '(blog)
    :kill-signal 'sigkill))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c b" "C-z c b")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c b" "background process")
#+END_SRC

** Emacs Lisp

I haven't started programming seriously in Emacs Lisp to know the ways around yet but this is what I have at present.

*** Macro step

Emacs has provisions for a macro and [[https://github.com/joddie/macrostep][this package]] interactively expands them.

#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :ensure t
  :commands (macrostep-expand
             macrostep-mode))
#+END_SRC

*** Auto compile

[[https://github.com/tarsius/auto-compile][Auto compile]] byte /recompiles/ files if they are byte-compiled already.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :ensure t)
#+END_SRC

** C/C++

I use C++ a lot while programming and this section tries to convert Emacs into a good environment for coding in C++. For a good introduction, [[https://www.youtube.com/watch?v=5FQwQ0QWBTU][take a look at this video]].

*** Consider header files to be C++

I usually don't code in C that much. Therefore, let's make sure Emacs considers ".h" files as C++ header files.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

*** Compile commands

The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Compilation.html][compile command]] bundled with Emacs is super useful. I have defined a few functions that help me compile things quickly.

#+BEGIN_SRC emacs-lisp
(defun sk/compile-cpp-omp-math ()
  "Compiles the file with OpenMP and math libraries"
  (interactive)
  (compile
   (concat "g++ -Wall -fopenmp -lgsl -lcblas -llapack -O2 -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-omp-simple ()
  "Compiles the file with OpenMP"
  (interactive)
  (compile
   (concat "g++ -Wall -fopenmp -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-mpi-math ()
  "Compiles the file with MPI and math libraries"
  (interactive)
  (compile
   (concat "/usr/local/openmpi/bin/mpic++ -Wall -lgsl -lcblas -llapack -larmadillo -O2 -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-mpi-simple ()
  "Compiles the file with MPI"
  (interactive)
  (compile
   (concat "/usr/local/openmpi/bin/c++ -Wall -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-hybrid-math ()
  "Compiles the file with OpenMP, MPI and math libraries"
  (interactive)
  (compile
   (concat "/usr/local/openmpi/bin/c++ -Wall -fopenmp -lgsl -lcblas -llapack -larmadillo -O2 -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-hybrid-simple ()
  "Compiles the file with OpenMP and MPI"
  (interactive)
  (compile
   (concat "/usr/local/openmpi/bin/c++ -Wall -fopenmp -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-math ()
  "Compiles the file with math libraries"
  (interactive)
  (compile
   (concat "g++ -Wall -lgsl -lcblas -llapack -larmadillo -O2 -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
(defun sk/compile-cpp-simple ()
  "Compiles the file"
  (interactive)
  (compile
   (concat "g++ -Wall -g -std=c++11 " (buffer-file-name) " -o " (file-name-sans-extension buffer-file-name) ".out")))
#+END_SRC

*** Rtags

[[https://github.com/Andersbakken/rtags][Rtags]] is an industrial grade indexer based on clang and its integration with Emacs is quite amazing.

#+BEGIN_SRC emacs-lisp
(use-package rtags
  :ensure t
  :defer 2
  :init
  (setq rtags-autostart-diagnostics t)
  (setq rtags-completions-enabled t))
#+END_SRC

*** Cmake IDE

[[https://github.com/atilaneves/cmake-ide][This]] is a package that sets up all the necessary configuration to work with C/C++.

#+BEGIN_SRC emacs-lisp
(use-package cmake-ide
  :ensure t
  :defer 2
  :config
  (cmake-ide-setup))
#+END_SRC

** Python

This is my python configuration.

*** Manage python

Let's use use-package to first manage python mode itself.

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure t
  :mode ("\\.py\\'" . python-mode)
  :config
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i"))
#+END_SRC

*** Anaconda mode

[[https://github.com/proofit404/anaconda-mode][Anaconda mode]] provides python code navigation and completion but you need to install a few dependencies first from ~pip~ first or it will install on its own.

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :ensure t
  :diminish anaconda-mode
  :diminish anaconda-eldoc-mode
  :commands (anaconda-mode
             anaconda-eldoc-mode
             anaconda-mode-find-assignments
             anaconda-mode-find-definitions
             anaconda-mode-find-file
             anaconda-mode-find-references
             anaconda-mode-show-doc
             anaconda-mode-go-back
             anaconda-mode-complete))
#+END_SRC

*** Virtual environment support

[[https://github.com/proofit404/pyenv-mode][This]] is a companion package in case I need to work with [[http://docs.python-guide.org/en/latest/dev/virtualenvs/][virtual environments]].

#+BEGIN_SRC emacs-lisp
(use-package pyenv-mode
  :ensure t
  :commands (pyenv-mode
             pyenv-mode-set
             pyenv-mode-unset))
#+END_SRC

*** Python formatting

I format python occasionally using [[https://github.com/paetzke/py-yapf.el][py-yapf]] which uses Google's [[https://github.com/google/yapf][yapf]] formatter.

#+BEGIN_SRC emacs-lisp
(use-package py-yapf
  :ensure t
  :commands (py-yapf-buffer
             py-yapf-enable-on-save))
#+END_SRC

*** Testing

I haven't started using this package but [[https://github.com/ionrock/pytest-el][it helps in writing tests]] which I intend to.

#+BEGIN_SRC emacs-lisp
(use-package pytest
  :ensure t
  :commands (pytest-all
             pytest-directory
             pytest-failed
             pytest-module
             pytest-one
             pytest-pdb-all
             pytest-pdb-directory
             pytest-pdb-module
             pytest-pdb-one))
#+END_SRC

** Statistics

I rarely use [[https://www.r-project.org/about.html][R]] and occasionally [[http://julialang.org][julia]] but since this is just one package, I might as well install it. It might come in handy.

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t
  :mode (("\\.R$" . R-mode)
         ("\\.r$" . R-mode)
         ("\\.jl$'" . julia-mode)))
#+END_SRC

The following are a couple of helper functions to open R and Julia shells in a vertical split.

#+BEGIN_SRC emacs-lisp
;; Vertical split julia REPL
(defun sk/julia-shell-here ()
  "opens up a new julia REPL in the directory associated with the current buffer's file."
  (interactive)
  (split-window-right)
  (other-window 1)
  (julia))

;; Vertical split r REPL
(defun sk/r-shell-here ()
  "opens up a new r REPL in the directory associated with the current buffer's file."
  (interactive)
  (split-window-right)
  (other-window 1)
  (R))
#+END_SRC

** MATLAB

I use [[http://www.mathworks.com/products/matlab/][MATLAB]] pretty often when I want to quickly type out some code and I use a OS X computer in my lab and have to manually set the path.

#+BEGIN_SRC emacs-lisp
(use-package matlab-mode
  :ensure t
  :mode ("\\.m$" . matlab-mode)
  :init
  (setq matlab-shell-command "/Applications/MATLAB_R2014a.app/bin/matlab"
        matlab-indent-function t)
  (eval-after-load 'matlab
    '(add-to-list 'matlab-shell-command-switches "-nosplash")))
#+END_SRC

The following is a helper function to open a MATLAB command line in a vertical split

#+BEGIN_SRC emacs-lisp
(defun sk/matlab-shell-here ()
  "opens up a new matlab shell in the directory associated with the current buffer's file."
  (interactive)
  (split-window-right)
  (other-window 1)
  (matlab-shell))
#+END_SRC

** Web

I have just recently started dabbling in HTML/CSS and JavaScript. So, this is an initial configuration I have come up with.

*** Web mode

[[http://web-mode.org][This]] is a fully featured, supposedly awesome, package to edit HTML in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html$" . web-mode))
#+END_SRC

*** JavaScript syntax highlighting

[[https://github.com/thomblake/js3-mode][This]] improves on the built-in JavaScript syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package js3-mode
  :ensure t
  :mode ("\\.js$" . js3-mode))
#+END_SRC

*** Coffeescript syntax highlighting

I use coffeescript only to edit my [[http://tracesof.net/uebersicht/][ubersicht]] configuration files.

#+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :ensure t
  :mode "\\.coffee$")
#+END_SRC

*** SCSS syntax highlighting

Occasionally I'm forced to open SCSS files.

#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t
  :mode "\\.scss$")
#+END_SRC

*** JSON mode

Syntax highlighting for =json= files.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :mode "\\.json$")
#+END_SRC

*** Nginx syntax highlighting

I haven't used [[https://www.nginx.com][nginx]] much but useful to have it.

#+BEGIN_SRC emacs-lisp
(use-package nginx-mode
  :ensure t
  :commands (nginx-mode))
#+END_SRC

*** Write fast HTML

[[https://github.com/smihica/emmet-mode][Emmet]] is very useful while writing HTML. Look in to the guide for more details as to how to use it.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :diminish (emmet-mode . "ε")
  :bind* (("C-z )" . emmet-next-edit-point)
          ("C-z (" . emmet-prev-edit-point))
  :commands (emmet-mode
             emmet-next-edit-point
             emmet-prev-edit-point))
#+END_SRC

**** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd ")" "C-z )")
(modalka-define-kbd "(" "C-z (")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  ")" "emmet next cursor exp"
  "(" "emmet prev cursor exp")
#+END_SRC

*** Render HTML pages real time

[[https://github.com/skeeto/impatient-mode][This]] package renders HTML in the web browser as you type.

#+BEGIN_SRC emacs-lisp
(use-package impatient-mode
  :ensure t
  :diminish (impatient-mode . "ι")
  :commands (impatient-mode))
#+END_SRC

*** JavaScript navigation

[[http://ternjs.net][Tern]] describes itself as a code analysis engine and [[https://github.com/ternjs/tern][this]] is an implementation to bring it into Emacs.

#+BEGIN_SRC emacs-lisp
(use-package tern
  :ensure t
  :diminish tern-mode
  :commands (tern-mode
             tern-find-definition
             tern-find-definition-by-name
             tern-get-docs
             tern-get-type
             tern-use-server
             tern-highlight-refs
             tern-rename-variable))
#+END_SRC

*** Node JS REPL

Bring [[https://nodejs.org/en/][node js]] to [[https://github.com/abicky/nodejs-repl.el][Emacs]].

#+BEGIN_SRC emacs-lisp
(use-package nodejs-repl
  :ensure t
  :commands (nodejs-repl
             nodejs-repl-send-buffer
             nodejs-repl-switch-to-repl
             nodejs-repl-send-region
             nodejs-repl-send-last-sexp
             nodejs-repl-execute
             nodejs-repl-load-file))
#+END_SRC

Managing node versions with [[https://github.com/rejeep/nvm.el][nvm.el]].

#+BEGIN_SRC emacs-lisp
(use-package nvm
  :ensure t
  :commands (nvm-use
             nvm-use-for))
#+END_SRC

*** Snatch JSON

Get the path to JSON element [[https://github.com/Sterlingg/json-snatcher][in Emacs]].

#+BEGIN_SRC emacs-lisp
(use-package json-snatcher
  :ensure t
  :commands (jsons-print-path))
#+END_SRC

*** Beautify

I'm not sure how useful [[https://github.com/yasuyk/web-beautify][this]] is but just like I have formatters for others, I'm keeping this.

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :ensure t
  :commands (web-beautify-css
             web-beautify-css-buffer
             web-beautify-html
             web-beautify-html-buffer
             web-beautify-js
             web-beautify-js-buffer))
#+END_SRC

** Error checking

[[http://www.flycheck.org/en/latest/][Flycheck]] is awesome.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :defer 2
  :bind* (("C-z ] l" . flycheck-next-error)
          ("C-z [ l" . flycheck-previous-error)
          ("C-z SPC l" . flycheck-list-errors))
  :config
  (global-flycheck-mode))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "] l" "C-z ] l")
(modalka-define-kbd "[ l" "C-z [ l")
(modalka-define-kbd "SPC l" "C-z SPC l")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "] l" "next error"
  "[ l" "previous error"
  "SPC l" "list errors")
#+END_SRC

** Auto completion

[[http://company-mode.github.io][Company mode]] standing for "complete any" is an auto-completion framework with a lot of third part packages and backends. Although I usually trigger manual completion, this is useful to have sometimes. This is a huge definition. Also, this is the only package I bind to =C-c=.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :commands (company-mode
             company-complete
             company-complete-common
             company-complete-common-or-cycle
             company-files
             company-dabbrev
             company-ispell
             company-c-headers
             company-jedi
             company-tern
             company-web-html
             company-auctex)
  :init
  (setq company-minimum-prefix-length 2
        company-require-match 0
        company-selection-wrap-around t
        company-dabbrev-downcase nil
        company-tooltip-limit 20                      ; bigger popup window
        company-tooltip-align-annotations 't          ; align annotations to the right tooltip border
        company-idle-delay .4                         ; decrease delay before autocompletion popup shows
        company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
  (eval-after-load 'company
    '(add-to-list 'company-backends '(company-files
                                      company-capf)))
  :bind (("C-c f" . company-files)
         ("C-c a" . company-dabbrev)
         ("C-c d" . company-ispell)
         :map company-active-map
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous)
              ([return] . company-complete-selection)
              ("C-w" . backward-kill-word)
              ("C-c" . company-abort)
              ("C-c" . company-search-abort))
  :diminish (company-mode . "ς")
  :config
  (global-company-mode)
  ;; C++ header completion
  (use-package company-c-headers
    :ensure t
    :bind (("C-c c" . company-c-headers))
    :config
    (add-to-list 'company-backends 'company-c-headers))
  ;; Python auto completion
  (use-package company-jedi
    :ensure t
    :bind (("C-c j" . company-jedi))
    :config
    (add-to-list 'company-backends 'company-jedi))
  ;; Tern for JS
  (use-package company-tern
    :ensure t
    :bind (("C-c t" . company-tern))
    :init
    (setq company-tern-property-marker "")
    (setq company-tern-meta-as-single-line t)
    :config
    (add-to-list 'company-backends 'company-tern))
  ;; HTML completion
  (use-package company-web
    :ensure t
    :bind (("C-c w" . company-web-html))
    :config
    (add-to-list 'company-backends 'company-web-html))
  ;; LaTeX autocompletion
  (use-package company-auctex
    :ensure t
    :bind (("C-c l" . company-auctex))
    :config
    (add-to-list 'company-backends 'company-auctex)))
#+END_SRC

** REPL

This is to interact with various shells.

*** Eshell

Eshell is a built-in shell that is written in Lisp. It's pretty good.

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :commands (eshell)
  :bind* (("C-z SPC u" . sk/eshell-vertical)
          ("C-z SPC U" . sk/eshell-horizontal))
  :init
  (setq eshell-glob-case-insensitive t
        eshell-scroll-to-bottom-on-input 'this
        eshell-buffer-shorthand t
        eshell-history-size 1024
        eshell-cmpl-ignore-case t
        eshell-aliases-file (concat user-emacs-directory ".eshell-aliases")
        eshell-last-dir-ring-size 512)
  :config
  (add-hook 'shell-mode-hook 'goto-address-mode))
#+END_SRC

Let's also define a couple of functions to open it in a vertical or horizontal split.

#+BEGIN_SRC emacs-lisp
;; Vertical split eshell
(defun sk/eshell-vertical ()
  "opens up a new shell in the directory associated with the current buffer's file."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (name (car (last (split-string parent "/" t)))))
    (split-window-right)
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))
    (eshell-send-input)))

;; Horizontal split eshell
(defun sk/eshell-horizontal ()
  "opens up a new shell in the directory associated with the current buffer's file."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (name (car (last (split-string parent "/" t)))))
    (split-window-below)
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))
    (eshell-send-input)))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z SPC u" . sk/eshell-vertical)
  ("C-z SPC U" . sk/eshell-horizontal))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC u" "C-z SPC u")
(modalka-define-kbd "SPC U" "C-z SPC U")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC u" "eshell vertical split"
  "SPC U" "eshell horizontal split")
#+END_SRC

*** Multi term

[[https://www.emacswiki.org/emacs/MultiTerm][Multi term]] doesn't provide any additional commands to built-in Emacs ~term~ and ~ansi-term~ but helps in managing multiple terminal buffers.

#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :ensure t
  :commands (multi-term)
  :bind* (("C-z SPC m" . sk/multi-term-vertical)
          ("C-z SPC M". sk/multi-term-horizontal)))
#+END_SRC

Let's also define a couple of wrapper functions to open this in splits.

#+BEGIN_SRC emacs-lisp
;; Vertical split multi-term
(defun sk/multi-term-vertical ()
  "opens up a new terminal in the directory associated with the current buffer's file."
  (interactive)
  (split-window-right)
  (other-window 1)
  (multi-term))

;; Horizontal split multi-term
(defun sk/multi-term-horizontal ()
  "opens up a new terminal in the directory associated with the current buffer's file."
  (interactive)
  (split-window-below)
  (other-window 1)
  (multi-term))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z SPC m" . sk/multi-term-vertical)
  ("C-z SPC M" . sk/multi-term-horizontal))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "SPC m" "C-z SPC m")
(modalka-define-kbd "SPC M" "C-z SPC M")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "SPC m" "multi-term vertical split"
  "SPC M" "multi-term horizontal split")
#+END_SRC

*** Interacting with Tmux

Although I am not using [[https://tmux.github.io][tmux]] as much as I used to when I was using Vim, [[https://github.com/syohex/emacs-emamux][this]] package helps in integrating with it.

#+BEGIN_SRC emacs-lisp
(use-package emamux
  :ensure t
  :commands (emamux:send-command
             emamux:run-command
             emamux:run-last-command
             emamux:zoom-runner
             emamux:inspect-runner
             emamux:close-runner-pane
             emamux:close-panes
             emamux:clear-runner-history
             emamux:interrupt-runner
             emamux:copy-kill-ring
             emamux:yank-from-list-buffers))
#+END_SRC

*** Compilation buffer

Whenever I run ~compile~, the buffer stays even after a successful compilation. Let's make it close automatically if the compilation is successful.

#+BEGIN_SRC emacs-lisp
(setq compilation-finish-functions
      (lambda (buf str)
        (if (null (string-match ".*exited abnormally.*" str))
            ;;no errors, make the compilation window go away in a few seconds
            (progn
              (run-at-time "0.4 sec" nil
                           (lambda ()
                             (select-window (get-buffer-window (get-buffer-create "*compilation*")))
                             (switch-to-buffer nil)))
              (message "No Compilation Errors!")))))
#+END_SRC

*** Quickrun

[[https://github.com/syohex/emacs-quickrun][This package]] helps you quickly run little pieces of code.

#+BEGIN_SRC emacs-lisp
(use-package quickrun
  :ensure t
  :commands (quickrun
             quickrun-region
             quickrun-with-arg
             quickrun-shell
             quickrun-compile-only
             quickrun-replace-region))
#+END_SRC

** Debugging

Emacs has a built-in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Commands-of-GUD.html][debugger]] interface but this is supposed to provide additional functions. I haven't tested it yet.

#+BEGIN_SRC emacs-lisp
(use-package realgud
  :ensure t
  :commands (realgud:gdb
             realgud:ipdb
             realgud:pdb))
#+END_SRC

** Hydras

*** Tmux integration

This menu helps in sending code and commands [[*Interacting with Tmux][to tmux]].

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-emamux (:color red
                               :hint nil)
 "
 ^Command^    ^Runner^                          ^Clipboard^
^^^^^^^^^^-----------------------------------------------------------------
 _s_: send    _r_: run        _c_: close          _y_: copy kill    _q_: quit
            _l_: last cmd   _C_: close other    _p_: paste tmux
            _z_: zoom       _h_: clear hist
            _i_: inspect    _I_: interrupt
"
 ("s" emamux:send-command)
 ("r" emamux:run-command)
 ("l" emamux:run-last-command)
 ("z" emamux:zoom-runner)
 ("i" emamux:inspect-runner)
 ("c" emamux:close-runner-pane)
 ("C" emamux:close-panes)
 ("h" emamux:clear-runner-history)
 ("I" emamux:interrupt-runner)
 ("y" emamux:copy-kill-ring)
 ("p" emamux:yank-from-list-buffers)
 ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c t" . sk/hydra-for-emamux/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c t" "C-z c t")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c t" "tmux code")
#+END_SRC

*** Emacs lisp

We define two hydras for Elisp. One for the [[*Macro step][macro step package]] and another for just regular editing.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-macro-step (:pre (macrostep-expand)
                               :color red
                               :hint nil)
  "
 _e_: expand    _j_: next macro    _C_: collapse all
 _c_: collapse  _k_: prev macro    _q_: quit
"
  ("e" macrostep-expand)
  ("c" macrostep-collapse)
  ("j" macrostep-next-macro)
  ("k" macrostep-prev-macro)
  ("C" macrostep-collapse-all)
  ("q" nil :color blue))
#+END_SRC

Then, the hydra for helping with Emacs Lisp code.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-elisp (:color red
                              :hint nil)
  "
 _r_: region    _e_: expression   _s_: ielm    _q_: quit
 _f_: func      _l_: last sexp
 _b_: buffer    _m_: macro step
"
  ("r" eval-region)
  ("f" eval-defun)
  ("b" eval-buffer)
  ("e" eval-expression :color blue)
  ("l" eval-last-sexp)
  ("m" sk/hydra-macro-step/body :exit t)
  ("s" ielm :color blue)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c e" . sk/hydra-for-elisp/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c e" "C-z c e")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
    "c e" "elisp code")
#+END_SRC

*** C/C++

C/C++ code navigation and compilation demands a hydra.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-cpp (:color blue
                            :hint nil)
  "
 ^Send^                                                    ^Navigate^
^^^^^^^^^^----------------------------------------------------------------------------------------------------------------------------------
 _B_: build            _o_: omp math      _O_: omp simple      _s_: sym-at-pt   _r_: ref-at-pt    _D_: diag    _f_: for-stack    _n_: next    _i_: info
 _c_: compile math     _m_: mpi math      _M_: mpi simple      _S_: symbol      _R_: references   _F_: fixit   _b_: back-stack   _p_: prev    _t_: type
 _C_: compile simple   _h_: hybrid math   _H_: hybrid simple   _v_: vir-at-pt   _N_: rename       _P_: preproc _d_: depends      _e_: enum    _q_: quit
"
  ("B" compile)
  ("o" sk/compile-cpp-omp-math)
  ("O" sk/compile-cpp-omp-simple)
  ("m" sk/compile-cpp-mpi-math)
  ("M" sk/compile-cpp-mpi-simple)
  ("h" sk/compile-cpp-hybrid-math)
  ("H" sk/compile-cpp-hybrid-simple)
  ("c" sk/compile-cpp-math)
  ("C" sk/compile-cpp-simple)
  ("s" rtags-find-symbol-at-point :color red)
  ("S" rtags-find-symbol :color red)
  ("r" rtags-find-references-at-point :color red)
  ("R" rtags-find-references :color red)
  ("v" rtags-find-virtuals-at-point :color red)
  ("D" rtags-diagnostics :color red)
  ("F" rtags-fixit :color red)
  ("P" rtags-preprocess-file :color red)
  ("f" rtags-location-stack-forward :color red)
  ("b" rtags-location-stack-back :color red)
  ("n" rtags-next-match :color red)
  ("p" rtags-previous-match :color red)
  ("d" rtags-print-dependencies :color red)
  ("i" rtags-print-symbol-info :color red)
  ("t" rtags-symbol-type :color red)
  ("e" rtags-print-enum-value-at-point :color red)
  ("N" rtags-rename-symbol :color red)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c c" . sk/hydra-for-cpp/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c c" "C-z c c")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c c" "c/cpp code")
#+END_SRC

*** Python

Hydra for Python code navigation, REPL evaluation, testing and formatting.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-py (:color blue
                           :hint nil)
  "
 ^Send^                     ^Navigate^                    ^Virtualenv^      ^Testing^                                        ^Format^
^^^^^^^^^^--------------------------------------------------------------------------------------------------------------------------------
 _r_: region    _s_: start    _d_: definition    _F_: file    _V_: pyenv        _ta_: test all    _tm_: test mod    _pd_: pdb dir    _y_: yapf
 _b_: buffer    _S_: switch   _a_: assignment    _B_: back    _u_: pyenv set    _td_: test dir    _to_: test one    _pm_: pdb mod    _q_: quit
 _f_: func                  _v_: reference     _D_: doc     _U_: pyenv unset  _tf_: test fail   _pa_: pdb all     _po_: pdb one
"
  ("r" python-shell-send-region)
  ("b" python-shell-send-buffer)
  ("f" python-shell-send-defun)
  ("s" run-python)
  ("S" python-shell-switch-to-shell)
  ("d" anaconda-mode-find-definitions :color red)
  ("D" anaconda-mode-show-doc :color red)
  ("a" anaconda-mode-find-assignments :color red)
  ("v" anaconda-mode-find-references :color red)
  ("F" anaconda-mode-find-file :color red)
  ("B" anaconda-mode-go-back :color red)
  ("V" pyenv-mode :color red)
  ("u" pyenv-mode-set)
  ("U" pyenv-mode-unset)
  ("ta" pytest-all)
  ("td" pytest-directory)
  ("tf" pytest-failed)
  ("tm" pytest-module)
  ("to" pytest-one)
  ("pa" pytest-pdb-all)
  ("pd" pytest-pdb-directory)
  ("pm" pytest-pdb-module)
  ("po" pytest-pdb-one)
  ("y" py-yapf-buffer)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c p" . sk/hydra-for-py/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c p" "C-z c p")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c p" "python code")
#+END_SRC

*** Statistics

Since both R and Julia are supported by ESS, one hydra is enough.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-ess (:color blue
                            :hint nil)
  "
 _f_: func        _l_: line    _j_: Julia  _S_: switch
 _s_: selection   _b_: buffer  _r_: R      _q_: quit
"
  ("f" ess-eval-function)
  ("l" ess-eval-line)
  ("s" ess-eval-region)
  ("b" ess-eval-buffer)
  ("j" sk/julia-shell-here)
  ("r" sk/r-shell-here)
  ("S" ess-switch-to-ESS)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c s" . sk/hydra-for-ess/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c s" "C-z c s")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c s" "stats code")
#+END_SRC

*** MATLAB

There is no facility for code navigation in MATLAB, and so this is just sending stuff to the MATLAB commandline.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-matlab (:color blue
                               :hint nil)
  "
 _c_: cell   _r_: region    _s_: start    _q_: quit
 _l_: line   _C_: command   _S_: switch
"
  ("c" matlab-shell-run-cell)
  ("l" matlab-shell-run-region-or-line)
  ("r" matlab-shell-run-region)
  ("C" matlab-shell-run-command)
  ("s" sk/matlab-shell-here)
  ("S" matlab-show-matlab-shell-buffer)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c m" . sk/hydra-for-matlab/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c m" "C-z c m")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c m" "matlab code")
#+END_SRC

*** Web

There are two hydras we use for Web editing - one for JavaScript specifically and one for web mode.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-js (:color blue
                           :hint nil)
  "
 ^Node^                                ^Tern^                                  ^Json^
^^^^^^^^^^-----------------------------------------------------------------------------------------
 _r_: region    _s_: start    _l_: load    _d_: definition    _h_: highlight refs    _j_: path
 _b_: buffer    _S_: switch              _n_: def by name   _u_: use-server        _q_: quit
 _x_: sexp      _e_: exec                _t_: type          _D_: doc
"
  ("r" nodejs-repl-send-region)
  ("b" nodejs-repl-send-buffer)
  ("x" nodejs-repl-send-last-sexp)
  ("s" nodejs-repl)
  ("S" nodejs-repl-switch-to-repl)
  ("e" nodejs-repl-execute)
  ("l" nodejs-repl-load-file :color red)
  ("d" tern-find-definition :color red)
  ("n" tern-find-definition-by-name :color red)
  ("t" tern-get-type :color red)
  ("D" tern-get-docs :color red)
  ("u" tern-use-server :color red)
  ("h" tern-highlight-refs)
  ("R" tern-rename-variable)
  ("j" jsons-print-path)
  ("q" nil :color blue))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-for-web (:color red
                            :hint nil)
  "
 ^Beautify^                                 ^Server^
^^^^^^^^^^-------------------------------------------------------------------
 _h_: html        _c_: css       _j_: js        _s_: httpd start   _i_: html real-time
 _H_: html buf    _C_: css buf   _J_: js buf    _S_: httpd stop    _q_: quit
"
  ("h" web-beautify-html)
  ("H" web-beautify-html-buffer)
  ("c" web-beautify-css)
  ("C" web-beautify-css-buffer)
  ("j" web-beautify-js)
  ("J" web-beautify-js-buffer)
  ("s" httpd-start :color blue)
  ("S" httpd-stop :color blue)
  ("i" impatient-mode :color blue)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c j" . sk/hydra-for-js/body)
  ("C-z c w" . sk/hydra-for-web/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c j" "C-z c j")
(modalka-define-kbd "c w" "C-z c w")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c j" "javscript code"
  "c w" "web code")
#+END_SRC

*** Quickrun

This is for [[*Quickrun][Quickrun]] functionality.

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-quickrun (:color blue
                             :hint nil)
  "
 _s_: quickrun     _a_: with arg    _c_: compile only       _q_: quit
 _r_: run region   _S_: shell       _R_: replace region
"
  ("s" quickrun)
  ("r" quickrun-region)
  ("a" quickrun-with-arg)
  ("S" quickrun-shell)
  ("c" quickrun-compile-only)
  ("R" quickrun-replace-region)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c q" . sk/hydra-quickrun/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c q" "C-z c q")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c q" "quickrun code")
#+END_SRC

*** Debugging

A small hydra to start appropriate debuggers

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-debug (;; :pre (load-library "realgud")
                          :color blue
                          :hint nil)
  "
 _G_: c-gdb         _P_: py-pdb        _I_: py-ipdb        _q_: quit
 _g_: realgud-gdb   _p_: realgud-pdb   _i_: realgud-ipdb
"
  ("G" gdb)
  ("g" realgud:gdb)
  ("P" pdb)
  ("p" realgud:pdb)
  ("I" ipdb)
  ("i" realgud:ipdb)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z c d" . sk/hydra-debug/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "c d" "C-z c d")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "c d" "debug code")
#+END_SRC

* Ivy, Counsel and Swiper

All of these are a part of [[https://github.com/abo-abo/swiper][the excellent swiper]] package. It changes the interface of Emacs and I love it.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :demand t
  :init
  (setq ivy-display-style 'fancy
        ivy-initial-inputs-alist nil)
  (setq ivy-re-builders-alist
        '((t . ivy--regex-fuzzy)))
  (setq completion-in-region-function 'ivy-completion-in-region)
  :diminish ivy-mode
  :bind (:map ivy-minibuffer-map
              ("C-t" . ivy-toggle-fuzzy)
              ("C-j" . ivy-done)
              ("C-m" . ivy-alt-done)
              ("C-S-m" . ivy-immediate-done)
              ("C-i" . ivy-dispatching-done)
              ("TAB" . ivy-dispatching-done))
  :bind* (("C-z B" . ivy-resume)
          ("C-z SPC r" . ivy-recentf))
  :config
  (ivy-mode 1)
  ;; Add swiper
  (use-package swiper
    :ensure t
    :demand t
    :commands (swiper)
    :bind (("C-s" . swiper)))
  ;; Search using spotlight
  (use-package spotlight
    :ensure t
    :commands (spotlight
               spotlight-fast)
    :bind* (("C-z SPC i" . spotlight)))
  ;; Add counsel to the mix
  (use-package counsel
    :ensure t
    :demand t
    :init
    (setq counsel-yank-pop-truncate t)
    :bind (("C-x 8" . counsel-unicode-char)
           ("C-s" . counsel-grep-or-swiper))
    :bind* (("C-z t" . counsel-imenu)
            ("C-z SPC I" . counsel-locate)
            ("C-z g s" . counsel-pt))
    :diminish counsel-mode
    :config
    (counsel-mode 1))
  ;; counsel projectile now
  (use-package counsel-projectile
    :ensure t
    :commands (counsel-projectile)
    :bind* (("C-z SPC p" . counsel-projectile))
    :init
    (setq projectile-completion-system 'ivy))
  ;; Ivy bibtex
  (use-package ivy-bibtex
    :ensure t
    :commands (ivy-bibtex)
    :bind* (("C-z SPC b" . ivy-bibtex))
    :init
    (setq bibtex-completion-bibliography '("~/Dropbox/org/references/multiphysics.bib" "~/Dropbox/org/references/chanceconstraints.bib"))
    (setq bibtex-completion-library-path "~/Dropbox/org/references/pdfs")
    (setq bibtex-completion-notes-path "~/Dropbox/org/references/articles.org")))
#+END_SRC

** Smex

[[https://github.com/nonsequitur/smex][smex]] is an amazing program that helps order the =M-x= commands based on usage and recent items. =counsel-M-x= has the option of using it internally when it finds this package. Let's install it.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :config
  (smex-initialize))
#+END_SRC

** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "B" "C-z B")
(modalka-define-kbd "t" "C-z t")
(modalka-define-kbd "g s" "C-z g s")
(modalka-define-kbd "SPC r" "C-z SPC r")
(modalka-define-kbd "SPC I" "C-z SPC I")
(modalka-define-kbd "SPC i" "C-z SPC i")
(modalka-define-kbd "SPC p" "C-z SPC p")
(modalka-define-kbd "SPC b" "C-z SPC b")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "B" "previous ivy"
  "t" "tags/func in buffer"
  "g s" "search project"
  "SPC r" "recent files"
  "SPC I" "locate"
  "SPC i" "spotlight"
  "SPC p" "switch projects"
  "SPC b" "bibliography")
#+END_SRC

* Fun

Emacs is fun!

** XKCD

Read [[http://xkcd.com][xkcd]] in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package xkcd
  :ensure t
  :commands (xkcd)
  :bind* (("C-c v g x" . xkcd)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g x" "C-z g x")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g x" "xkcd")
#+END_SRC

** Stack exchange

Browse [[http://stackexchange.com][stackexchange]] within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package sx
  :ensure t
  :commands (sx-tab-all-questions)
  :bind* (("C-z g X" . sx-tab-all-questions)))
#+END_SRC

*** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g X" "C-z g X")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements
  "g X" "stack exchange")
#+END_SRC

** Keep track of accounts

[[http://www.ledger-cli.org][Ledger]] is a command-line utility to keep track of finances. I'm still experimenting with it.

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :ensure t
  :mode "\\.dat$")
#+END_SRC

** Gtalk

You can use the [[https://www.emacswiki.org/emacs/JabberEl][jabber protocol]] to chat from within Emacs.

#+BEGIN_SRC emacs-lisp
;; Jabber
(use-package jabber
  :ensure t
  :commands (jabber-connect)
  :init
  (setq jabber-history-enabled t
        jabber-activity-mode nil
        jabber-use-global-history nil
        jabber-backlog-number 40
        jabber-backlog-days 30)
  (setq jabber-alert-presence-message-function
        (lambda (who oldstatus newstatus statustext) nil))
  ;; Account settings
  (setq jabber-account-list
        '(("sriram.krish.92@gmail.com"
           (:network-server . "talk.google.com")
           (:connection-type . ssl)))))
#+END_SRC

** IRC

I don't really hang around any IRC channels but planning to do so some day.

#+BEGIN_SRC emacs-lisp
(use-package circe
  :ensure t
  :commands (circe))
#+END_SRC

** Touch typing

Learn touch typing from within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package typit
  :ensure t
  :commands (typit))
#+END_SRC

** Learn the most frequently used keys

To track habits, maybe?

#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :ensure t
  :init
  (setq keyfreq-excluded-commands
        '(self-insert-command
          org-self-insert-command
          company-ignore
          abort-recursive-edit
          forward-char
          modalka-mode
          backward-char
          previous-line
          next-line))
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC

** Google stuff

[[https://github.com/Malabarba/emacs-google-this][This]] is a pretty useful package that lets you Google stuff from within Emacs.

#+BEGIN_SRC emacs-lisp
(use-package google-this
  :ensure t
  :commands (google-this-word
             google-this-region
             google-this-symbol
             google-this-clean-error-string
             google-this-line
             google-this-search
             google-this-cpp-reference))
#+END_SRC

*** Hydra

A hydra for googling things!

#+BEGIN_SRC emacs-lisp
(defhydra sk/hydra-google (:color blue
                           :hint nil)
  "
 _w_: word   _r_: region    _v_: symbol   _l_: line
 _g_: google _c_: cpp       _s_: string   _q_: quit
 "
  ("w" google-this-word)
  ("r" google-this-region)
  ("v" google-this-symbol)
  ("s" google-this-clean-error-string)
  ("l" google-this-line)
  ("g" google-this-search)
  ("c" google-this-cpp-reference)
  ("q" nil :color blue))
#+END_SRC

**** Key binding

#+BEGIN_SRC emacs-lisp
(bind-keys*
  ("C-z g G" . sk/hydra-google/body))
#+END_SRC

***** Modal binding

#+BEGIN_SRC emacs-lisp
(modalka-define-kbd "g G" "C-z g G")
#+END_SRC

Which key modal explanation

#+BEGIN_SRC emacs-lisp
(which-key-add-key-based-replacements "g G" "google now")
#+END_SRC

* Local configuration

There is provision to put and load a local configuration. For example, account and password details for [[*Gtalk][Gtalk]] can be stored here. Here is the code that provides that support.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p (concat user-emacs-directory "local.org"))
  (org-babel-load-file (concat user-emacs-directory "local.org")))
#+END_SRC

Also, note that you can redefine any of the functions that have been defined here. For example, if you use the following code for [[*Capture][Org capture]], it will overwrite the one that is already supplied with this configuration. This changes the name of the capture template and the directory in which it's stored. Similarly, the [[*Default directory][directory in which org stores files]] or the [[*Agenda][agenda files]] can also be changed.

#+BEGIN_SRC emacs-lisp :tangle no
(setq org-capture-templates '(

        ;; For taking notes on random things
        ("n"               ; key
         "My Notes"            ; name
         entry             ; type
         (file+headline "~/OneDrive/org/notes.org" "Notes")  ; target
         "* %? %(org-set-tags)  :note:\n:PROPERTIES:\n:Created: %U\n:Linked: %A\n:END:\n%i"  ; template
         :prepend t        ; properties
         :empty-lines 1    ; properties
         :created t        ; properties
         :kill-buffer t))) ; properties

#+END_SRC

* Key bindings

This section documents the key bindings that help to find other key-bindings. Note that when you search the keybindings, the Emacs ones are shown by default. These tend to be of the form =C-z g g=. The corresponding Modalka mode binding is just =g g=. So Pressing =C-z= or pressing =Esc= to toggle Modalka mode produces similar results (except, of course, you need not press =Esc= every time you want to use a binding in Modalka mode)

** Meta

#+NAME: meta_bindings
| Modalka state binding | Emacs state binding | Function                |
|-----------------------+---------------------+-------------------------|
| ?                     | C-z ?               | Show top level bindings |
| SPC ?                 | C-h b               | search bindings         |
| M                     | C-u                 | universal argument      |

** Quitting and restarting Emacs

#+NAME: quit_bindings
| Modalka state binding | Emacs state binding | Function                |
|-----------------------+---------------------+-------------------------|
| : q                   | C-x C-c             | Prompt to save and quit |
| : r                   | C-x M-c             | Quit and [[*Restart emacs from emacs][restart-emacs]]  |
| : t                   | C-z : t             | Emacs startup time      |

** Navigation

#+NAME: navigation
| Modalka state binding | Emacs state binding | Function                                  |
|-----------------------+---------------------+-------------------------------------------|
| j                     | C-n                 | next line                                 |
| k                     | C-p                 | previous line                             |
| h                     | C-b                 | previous character                        |
| l                     | C-f                 | next character                            |
| g g                   | M-<                 | top of buffer                             |
| G                     | M->                 | bottom of buffer                          |
| }                     | M-}                 | next para/org element                     |
| {                     | M-{                 | previous para/org element                 |
| J                     | C-v                 | scroll down                               |
| K                     | M-v                 | scroll up                                 |
| H                     | C-x <               | scroll left                               |
| L                     | C-x >               | scroll right                              |
| e                     | M-f                 | next word                                 |
| b                     | M-b                 | previous word                             |
| 0                     | C-a                 | [[*Smarter start of line][start of line]]                             |
| $                     | C-e                 | end of line                               |
| f                     | C-z f               | find character in line via [[*Avy][Avy]]            |
| F                     | C-z F               | goto line                                 |
| W                     | C-z W               | find two characters in file               |
| /                     | C-s                 | search in buffer                          |
| SPC SPC               | C-s                 | search in buffer                          |
| g s                   | C-z g s             | search in project                         |
| g e                   | C-z g e             | extract word from project                 |
| n                     | M-n                 | next item/history                         |
| N                     | M-p                 | previous item/history                     |
| ;                     | C-z ;               | [[*Back button][forward local change]]                      |
| ,                     | C-z ,               | backward local change                     |
| >                     | C-z >               | forward global change                     |
| <                     | C-z <               | backward global change                    |
| %                     | C-z %               | [[*Go to matching parenthesis, like Vi][matching parenthesis]]                      |
| +                     | C-z +               | [[*Bookmark navigation][Bookmark navigation]]                       |
| z                     | C-l                 | recenter screen                           |
| #                     | C-z #               | [[*Highlight symbol][highlight symbol]] like this                |
| g r                   | C-z g r             | remove all highlighted symbols            |
| g j                   | C-z g j             | find next like this                       |
| g k                   | C-z g k             | find previous like this                   |
| *                     | C-z *               | [[*Highlight symbol][search for word under cursor]]              |
| w                     | C-z w               | [[*Window navigation][Window navigation hydra]]                   |
| g w                   | C-x 3               | split window vertically                   |
| g W                   | C-x 2               | split window horizontally                 |
| t                     | C-z t               | [[*Ivy, Counsel and Swiper][tags in buffer]]                            |
| T                     | C-x T               | [[*Tags based navigation][tags based navigation in project]]          |
| g t                   | C-z g t             | create tags for code                      |
| g T                   | C-z g T             | update tags for code                      |
| g i                   | C-z g i             | [[*Beacon mode][blink cursor]]                              |
| C s                   | C-z C s             | [[*Perspective][switch perspective]]                        |
| C a                   | C-z C a             | add buffer to perspective                 |
| C A                   | C-z C A             | set buffer in perspective                 |
| C b                   | C-z C b             | switch to buffer in perspective           |
| C c                   | C-z C c             | close perspective                         |
| C C                   | C-z C C             | last perspective                          |
| C i                   | C-z C i             | import perspective                        |
| C k                   | C-z C k             | kill buffer in perspective                |
| C n                   | C-z C n             | next perspective                          |
| C p                   | C-z C p             | previous perspective                      |
| C r                   | C-z C r             | rename perspective                        |
| ] ]                   | C-x n n             | narrow to region                          |
| [ [                   | C-x n w             | widen narrowed region                     |
| [ s                   | C-z [ s             | [[*Flyspell go to the previous spell error][previous spelling error]]                   |
| ] s                   | C-z ] s             | next spelling error                       |
| [ d                   | C-z [ d             | turn the PDF previous page                |
| ] d                   | C-z ] d             | [[*Turn the adjoining PDF][Turn the adjoining PDF]] next page          |
| g m                   | C-z g m             | make frame                                |
| g M                   | C-z g M             | close frame                               |
| g n                   | C-z g n             | select frame by name                      |
| g N                   | C-z g N             | name frame                                |
| g f                   | C-z g f             | find file/url under cursor                |
| SPC f                 | C-x C-f             | find file browsing by directory           |
| SPC p                 | C-z SPC p           | switch between projects                   |
| SPC d                 | C-z SPC d           | find files in project based on [[*Projectile][Projectile]] |
| SPC r                 | C-z SPC r           | [[*Ivy, Counsel and Swiper][recent files]]                              |
| SPC t                 | C-z SPC t           | [[*Ivy, Counsel and Swiper][spotlight search]]                          |
| SPC y                 | C-z SPC y           | [[*Ivy, Counsel and Swiper][locate]]                                    |
| SPC n                 | C-z SPC n           | [[*Neotree][directory navigation]]                      |
| Z                     | C-z Z               | zoom in to the current window             |
| SPC q                 | C-x 0               | close current window                      |
| SPC z                 | C-z SPC z           | [[*Non native full screen][Non native full screen]]                    |
| SPC a                 | C-x b               | switch to open buffer                     |
| SPC k                 | C-x k               | kill buffer                               |
| SPC x                 | C-h f               | find help regarding function              |
| SPC X                 | C-h v               | find help regarding variable              |
| SPC v                 | C-z SPC v           | view configuration file                   |
| SPC j                 | M-x                 | find command                              |

** Editing

#+NAME: editing
| Modalka state binding | Emacs state binding | Function                             |
|-----------------------+---------------------+--------------------------------------|
| y                     | M-w                 | copy selected region                 |
| Y                     | C-z Y               | copy to end of line                  |
| p                     | C-y                 | paste                                |
| P                     | M-y                 | paste history                        |
| x                     | C-d                 | delete character                     |
| d                     | C-S-w               | cut selection                        |
| D                     | C-k                 | delete to end of line                |
| q                     | C-x (               | start macro                          |
| Q                     | C-x )               | end macro                            |
| @                     | C-z @               | [[*Macros][macros play menu]]                     |
| .                     | C-z .               | repeat previous command              |
| =                     | C-z =               | indent region                        |
| O                     | C-o                 | [[*Open line][Open line above]]                      |
| g O                   | C-z g O             | open line below                      |
| g S                   | C-z g S             | split line                           |
| g J                   | C-z g J             | [[*Join line][join line]]                            |
| g u                   | C-z g u             | lower case region                    |
| g U                   | C-z g U             | upper case region                    |
| g C                   | C-z g C             | capitalize region                    |
| g q                   | C-z g q             | format paragraph                     |
| g c                   | C-z g c             | comment line or region               |
| v                     | C-SPC               | start selecting region               |
| V                     | C-z V               | start selecting rectangle region     |
| X                     | C-x C-x             | exchange cursor and end of selection |
| a                     | C-z a               | expand region                        |
| A                     | C-z A               | contract region                      |
| i a                   | C-x h               | select whole buffer                  |
| i l                   | C-z i l             | [[*Select the current line][select the current line]]              |
| i p                   | C-z i p             | [[*Expand region][select the para]]                      |
| i f                   | C-z i f             | select function                      |
| i w                   | C-z i w             | select word                          |
| i v                   | C-z i v             | select variable                      |
| i u                   | C-z i u             | select url                           |
| i t                   | C-z i t             | select latex math                    |
| i b                   | C-z i b             | select inside pairs ()               |
| i q                   | C-z i q             | select inside quotes                 |
| i c                   | C-z i c             | select comment                       |
| i o                   | C-z i o             | select org code block                |
| i s                   | C-z i s             | select org subtree                   |
| i m                   | C-z i m             | select python method                 |
| i j                   | C-z i j             | select julia/ruby block              |
| i h                   | C-z i h             | [[*Highlight diffs][select git hunk]]                      |
| s a                   | C-z s a             | [[*Smartparens][Smartparens]] beginning of block       |
| s b                   | C-z s b             | smartparens backward expression      |
| s c                   | C-z s c             | smartparens change surroundings      |
| s d                   | C-z s d             | smartparens delete expression        |
| s e                   | C-z s e             | smartparens end of block             |
| s f                   | C-z s f             | smartparens forward expression       |
| s h                   | C-z s h             | smartparens backward down expression |
| s j                   | C-z s j             | smartparens down expression          |
| s k                   | C-z s k             | smartparens backward up expression   |
| s l                   | C-z s l             | smartparens up expression            |
| s n                   | C-z s n             | smartparens next block               |
| s p                   | C-z s p             | smartparens previous block           |
| s q                   | C-z s q             | switch quotes                        |
| s s                   | C-z s s             | surroundings unwrap                  |
| s S                   | C-z s S             | surroundings backward unwrap         |
| s x                   | C-z s x             | smartparens transpose expressions    |
| s y                   | C-z s y             | smartparens copy expression          |
| m i                   | C-z m i             | multiple interactive edits           |
| m a ([[*Region bindings mode][region binding]])  | C-z m a             | mark all similar selection           |
| m d (region binding)  | C-z m d             | mark all in function definition      |
| m e (region binding)  | C-z m e             | edit start of lines                  |
| m E (region binding)  | C-z m E             | edit end of lines                    |
| m f (region binding)  | C-z m f             | edit next like this                  |
| m F (region binding)  | C-z m F             | edit previous like this              |
| m l (region binding)  | C-z m l             | insert letters                       |
| m n (region binding)  | C-z m n             | insert numbers                       |
| m s (region binding)  | C-z m s             | skip next like this                  |
| m S (region binding)  | C-z m S             | skip previous like this              |
| \                     | C-c C-c             | simulate C-c C-c                     |
| SPC w                 | C-x C-s             | save                                 |
| SPC i                 | C-c C-e             | edit the result inline               |
| SPC h                 | C-c C-w             | refile work                          |
| SPC o                 | C-c C-k             | abort                                |
| SPC g                 | C-c C-f             | follow mode                          |
| SPC s                 | C-z SPC s           | [[*Visual replace][visual replace word in buffer/region]] |
| S                     | C-z S               | [[*Snippets][snippet select]]                       |
| g R                   | C-z g R             | [[*Rename the current buffer and the file associated with it][rename current file]]                  |
| g K                   | C-z g K             | [[*Delete the current buffer and the file associated with it][delete current file]]                  |
| g y                   | C-z g y             | [[*Copy the current file path][copy current file path]]               |
| g D                   | C-z g D             | [[*Duplicate][duplicate line]]                       |
| [ w                   | C-z [ w             | [[*Transposing words][exchange with previous word]]          |
| ] w                   | C-z ] w             | exchange with next word              |
| [ c                   | C-z [ c             | [[*Transposing characters][exchange with previous character]]     |
| ] c                   | C-z ] c             | exchange with next character         |
| [ e                   | C-z [ e             | [[*Move lines][move line/region up]]                  |
| ] e                   | C-z ] e             | move line/region down                |
| g +                   | C-z g +             | [[*Change from snake case to camel case][Change from snake case to camel case]] |
| g _                   | C-z g _             | [[*Make current word snake case][Make current word snake case]]         |
| g -                   | C-z g -             | [[*Kebab case current word][Kebab case current word]]              |
| g =                   | C-z g =             | [[*Add for auto correction][Add for auto correction]]              |
| E                     | C-z E               | [[*Rectangle edit mode][Rectangle edit mode]]                  |
| "                     | C-z "               | [[*Registers][Registers]]                            |

** Visual aids

#+NAME: visual_aids
| Modalka state binding | Emacs state binding | Function                 |
|-----------------------+---------------------+--------------------------|
| SPC c                 | C-z SPC c           | load color themes        |
| <Bar>                 | C-z <Bar>           | [[*Origami - folding based on indentation/syntax][syntax based fold]]        |
| -                     | C-z -               | [[*Vimish fold - Fold regions based on selection][fold toggle]]              |
| _                     | C-z _               | [[*Vimish fold][fold menu]]                |
| g a                   | C-z g a             | [[*Activate minor modes][Activate minor modes]]     |
| g d                   | C-z g d             | [[*Distraction free mode][Distraction free mode]]    |
| g F                   | C-z g F             | Distraction free focus   |
| g ?                   | C-z g ?             | [[*Check out the definition of the word][Check definition of word]] |

** Org

#+NAME: org_mode
| Modalka state binding | Emacs state binding | Function                    |
|-----------------------+---------------------+-----------------------------|
| o a                   | C-z o a             | org agenda                  |
| o v                   | C-z o v             | [[*Agenda view][org agenda view]]             |
| o c                   | C-z o c             | org capture                 |
| o b                   | C-z o b             | [[*Check boxes][org check box]]               |
| o d                   | C-z o d             | org todo                    |
| o D                   | C-z o D             | [[*Hydra for task management][org deadlines]]               |
| o e                   | C-z o e             | org export                  |
| o f                   | C-z o f             | [[*Deft][org filter]]                  |
| o j                   | C-z o j             | [[*Jump][org jump]]                    |
| o k                   | C-z o k             | org kill subtree            |
| o l                   | C-z o l             | org latex toggle            |
| o m                   | C-z o m             | [[*Table manipulation][org manipulate table]]        |
| o o                   | C-z o o             | [[*Organize trees][org organize]]                |
| o p                   | C-z o p             | [[*Org drill][org practice]]                |
| o P                   | C-z o P             | [[*Properties][org properties]]              |
| o w                   | C-z o w             | org edit in special buffer  |
| o q                   | C-z o q             | org quit special buffer     |
| o r                   | C-z o r             | [[*Org ref][org ref]]                     |
| o s                   | C-z o s             | org store link              |
| o i                   | C-z o i             | org insert link             |
| o L                   | C-z o L             | org toggle link display     |
| o C                   | C-z o C             | [[*Clocking functionality][org clocking]]                |
| o S                   | C-z o S             | org make subtree            |
| o A                   | C-z o A             | org archive                 |
| o g                   | C-z o g             | org goto                    |
| o I                   | C-z o I             | org toggle inline images    |
| o V                   | C-z o V             | org reveal                  |
| o R                   | C-z o R             | org refile                  |
| o h                   | C-z o h             | org toggle heading          |
| o H                   | C-z o H             | org heading respect content |
| o u                   | C-z o u             | update dblock               |
| o U                   | C-z o U             | update all dblocks          |
| o [                   | C-z o [             | org widen                   |
| o ]                   | C-z o ]             | org narrow to subtree       |
| o n                   | C-z o n             | [[*Interleave][org interleave]]              |
| o N                   | C-z o N             | org note                    |
| o z                   | C-z o z             | org clone indirect buffer   |
| o F                   | C-z o F             | org attach                  |
| o E                   | C-z o E             | org set effort              |
| o B                   | C-z o B             | org table blank field       |
| o y                   | C-z o y             | org copy subtree            |
| o t                   | C-z o t             | org tags command            |
| o <                   | C-z o <             | org date from calendar      |
| o >                   | C-z o >             | org goto calendar           |

** Programming

#+NAME: programming
| Modalka state binding | Emacs state binding | Function                    |
|-----------------------+---------------------+-----------------------------|
| SPC e                 | C-z SPC e           | [[*Magit][explore git repository]]      |
| g b                   | C-z g b             | git blame                   |
| ] h                   | C-z ] h             | [[*Highlight diffs][next git hunk]]               |
| [ h                   | C-z [ h             | previous git hunk           |
| g h                   | C-z g h             | goto git hunk               |
| g H                   | C-z g H             | revert git hunk             |
| g l                   | C-z g l             | [[*Git time machine][git log time machine]]        |
| g L                   | C-z g L             | git log switch branch       |
| g p                   | C-z g p             | [[*Gists][gist post public]]            |
| g P                   | C-z g P             | gist post private           |
| g o                   | C-x C-e             | emacs lisp evaluate         |
| c b                   | C-z c b             | [[*Start services][start background processes]]  |
| c e                   | C-z c e             | [[*Emacs lisp][emacs lisp code menu]]        |
| c c                   | C-z c c             | [[*C/C++][c/c++ code menu]]             |
| c p                   | C-z c p             | [[*Python][python code menu]]            |
| c s                   | C-z c s             | [[*Statistics][statistics code menu]]        |
| c m                   | C-z c m             | [[*MATLAB][MATLAB code menu]]            |
| c j                   | C-z c j             | [[*Web][JavaScript code menu]]        |
| c w                   | C-z c w             | web mode code menu          |
| c d                   | C-z c d             | [[*Debugging][Debugging code menu]]         |
| c t                   | C-z c t             | [[*Tmux integration][Tmux code menu]]              |
| ] l                   | C-z ] l             | [[*Error checking][next error]]                  |
| [ l                   | C-z [ l             | previous error              |
| SPC l                 | C-z SPC l           | list errors                 |
| SPC u                 | C-z SPC u           | [[*Eshell][Eshell vertical split]]       |
| SPC U                 | C-z SPC U           | Eshell horizontal split     |
| SPC m                 | C-z SPC m           | [[*Multi term][Multi term vertical split]]   |
| SPC M                 | C-z SPC M           | Multi term horizontal split |
| B                     | C-z B               | [[*Ivy, Counsel and Swiper][ivy resume]]                  |
| SPC b                 | C-z SPC b           | ivy bibtex                  |

** Fun

#+NAME: fun
| Modalka state binding | Emacs state binding | Function       |
|-----------------------+---------------------+----------------|
| g x                   | C-z g x             | [[*XKCD][XKCD]]           |
| g X                   | C-z g X             | [[*Stack exchange][Stack exchange]] |
| g G                   | C-z g G             | [[*Google stuff][Google stuff]]   |
* Automatically invoke tangle on save

This portion of comments let Emacs know that it has to [[*Tangle%20on%20save][invoke tangle on save]]. Since the actual code is in comment form, I have included the code to be included in verbatim form. Also, note that Emacs might prompt you if you are OK with the local variables being executed. Press "!" to tell Emacs that is OK and to ask it to save it to the [[*Custom%20file][Custom file]].

#+BEGIN_VERBATIM
# Local Variables:
# eval: (when (fboundp #'tangle-if-init) (add-hook 'after-save-hook #'tangle-if-init))
# End:
#+END_VERBATIM

# Local Variables:
# eval: (when (fboundp #'tangle-if-init) (add-hook 'after-save-hook #'tangle-if-init))
# End:
